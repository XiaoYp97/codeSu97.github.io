[{"content":"计算机的存储设备 计算机中包括三种类型的存储设备：\n硬盘（hard disk）, 用于长期存储大量数据 内存（random-access memory, RAM）, 用于临时存储程序运行中正在处理的数据 缓存（cache memory）, 用于存储经常访问的数据和指令 在程序运行时，数据会从硬盘中被读取到内存中，供 CPU 计算使用。缓存可以看作 CPU 的一部分，它通过智能地从内存加载数据，给 CPU 提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖。\n硬盘 内存 缓存 用途 长期存储数据，包括操作系统、程序、文件等 临时存储当前运行的程序和正在处理的数据 存储经常访问的数据和指令，减少 CPU 访问内存的次数 易失性 断电后数据不会丢失 断电后数据会丢失 断电后数据会丢失 容量 较大，TB 级别 较小，GB 级别 非常小，MB 级别 速度 较慢，几百到几千 MB/s 较快，几十 GB/s 非常快，几十到几百 GB/s 价格 较便宜，几毛到几元 / GB 较贵，几十到几百元 / GB 非常贵，随 CPU 打包计价 硬盘难以被内存取代 首先，内存中的数据在断电后会丢失，因此它不适合长期存储数据； 其次，内存的成本是硬盘的几十倍，这使得它难以在消费者市场普及。 缓存的大容量和高速度难以兼得 随着 L1、L2、L3 缓存的容量逐步增大，其物理尺寸会变大，与 CPU 核心之间的物理距离会变远，从而导致数据传输时间增加，元素访问延迟变高。 在当前技术下，多层级的缓存结构是容量、速度和成本之间的最佳平衡点。 内存效率 内存是有限的，且同一块内存不能被多个程序共享，因此我们希望数据结构能够尽可能高效地利用空间。\n数组的元素紧密排列，不需要额外的空间来存储链表节点间的引用（指针），因此空间效率更高。然而，数组需要一次性分配足够的连续内存空间，这可能导致内存浪费，数组扩容也需要额外的时间和空间成本。相比之下，链表以“节点”为单位进行动态内存分配和回收，提供了更大的灵活性。\n在程序运行时，随着反复申请与释放内存，空闲内存的碎片化程度会越来越高，从而导致内存的利用效率降低。数组由于其连续的存储方式，相对不容易导致内存碎片化。相反，链表的元素是分散存储的，在频繁的插入与删除操作中，更容易导致内存碎片化。\n内存碎片化 在程序运行过程中，反复申请和释放内存会导致内存碎片化，从而降低内存利用效率。\n内存碎片化的本质是内存分配和释放的不连续操作导致空闲内存分散，无法高效利用。\n理解这一机制有助于：\n优化内存分配策略（如减少小对象分配）。 选择合适的工具（如内存池或高效分配器）。 在系统设计阶段规避潜在的内存瓶颈。 内存分配的基本机制 程序运行时，动态内存（堆内存）的分配和释放由内存管理器（如 malloc/free）负责。\n内存管理器需要维护一个空闲内存块列表，记录哪些内存区域是未被占用的。\n内存申请：当程序申请内存时，内存管理器会从空闲列表中找到一个足够大的连续内存块分配给程序。 内存释放：当程序释放内存时，内存管理器将释放的内存块重新标记为空闲，并合并相邻的空闲块（如果可能）。 内存碎片化的类型 内存碎片化分为两种类型：\n外部碎片（External Fragmentation） 空闲内存分散在已分配内存块之间，形成许多小的、不连续的空闲块。\n即使总的空闲内存足够，但缺乏足够大的连续内存块，导致无法满足后续较大的内存申请请求。\n假设堆内存初始为 100KB 连续空间。 程序依次申请了 20KB、30KB、50KB 的内存块，然后释放中间的 30KB。 此时空闲内存为 30KB，但被分割为两部分：20KB（已分配）和 30KB（空闲）之间夹着 50KB（已分配）。 若程序需要申请 40KB，虽然总空闲内存为 30KB + 后续可能的其他空闲块，但无法找到连续的 40KB 空间，导致分配失败。 内部碎片（Internal Fragmentation） 分配给程序的内存块中，未被实际使用的部分。浪费已分配的内存空间。\n内存管理器按固定大小（如 16KB）分配内存块，但程序仅需要 10KB。 剩余的 6KB 未被使用，但无法被其他程序利用。 内存碎片化的形成过程 初始状态 堆内存为连续的空闲块（例如 100KB）。\n多次分配与释放 程序依次申请不同大小的内存块（如 20KB、30KB、40KB）。 随后释放部分内存块（如中间的 30KB）。 释放的内存块被标记为空闲，但可能与相邻的空闲块合并（取决于内存管理器的策略）。 碎片化加剧 反复的分配和释放操作会导致空闲内存块逐渐被分割成更小的、非连续的块。 即使总空闲内存足够，但无法满足较大的连续内存请求。 示例场景 1 2 3 4 5 初始内存 [----------------100KB----------------] 分配后： [A:20KB][B:30KB ][C:50KB ] 释放B后： [A:20KB][---30KB---][C:50KB ] 此时，总空闲内存为 30KB，但被分割为两部分（假设内存管理器未合并相邻空闲块）。 若申请 40KB，会失败，因为没有连续的 40KB 空间。 内存碎片化的影响 内存利用率下降：大量小空闲块无法被有效利用。 分配延迟增加：内存管理器需要更复杂的策略来查找可用内存块。 程序崩溃风险：无法满足关键内存申请时，程序可能崩溃或抛出异常（如 OutOfMemoryError）。 内存管理器的应对策略 为减少碎片化，内存管理器会采用以下策略：\n合并相邻空闲块（Coalescing） 释放内存时，检查相邻块是否空闲，若空闲则合并为一个更大的块。 示例：释放 B（30KB）后，若相邻块 A 或 C 是空闲的，则合并它们。 内存分配算法 首次适应（First Fit）：从空闲列表头部开始查找第一个足够大的块。 最佳适应（Best Fit）：查找最小的足够大的块。 最差适应（Worst Fit）：查找最大的块。 伙伴系统（Buddy System）：将内存按 2 的幂次大小分割，便于合并。 内存池（Memory Pool） 预分配多个固定大小的内存块，减少内部碎片（但可能增加外部碎片）。 实际应用中的解决方案 避免频繁小内存分配：使用对象池或缓存重用对象。 使用高效的内存分配器：如 jemalloc 或 tcmalloc，优化碎片化问题。 垃圾回收（GC）：在托管语言（如 Java、C#）中，GC 会自动合并碎片（但仍有停顿时间成本）。 内存压缩：移动已分配内存块以合并空闲空间（需暂停程序，如某些 GC 策略）。 缓存效率 缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。\n由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。\n显然，“缓存未命中”越少，CPU 读写数据的效率就越高，程序性能也就越好。\n我们将 CPU 从缓存中成功获取数据的比例称为缓存命中率（cache hit rate），这个指标通常用来衡量缓存效率。\n为了尽可能达到更高的效率，缓存会采取以下数据加载机制。\n缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。 预取机制：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。 空间局部性：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。 时间局部性：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。 实际上，数组和链表对缓存的利用效率是不同的，主要体现在以下几个方面。\n占用空间：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。 缓存行：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。 预取机制：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。 空间局部性：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。 总体而言，数组具有更高的缓存命中率，因此它在操作效率上通常优于链表。但需要注意的是，高缓存效率并不意味着数组在所有情况下都优于链表。实际应用中选择哪种数据结构，应根据具体需求来决定。\n","date":"2025-03-19T14:41:19+08:00","permalink":"https://codeSu97.github.io/p/ram_and_cache/","title":"计算机内存与缓存"},{"content":"栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。\n栈，Stack 栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）。\n想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。\n不能从中间也不能从底部增加或拿走盘子！\n增加数据叫做 进栈（pushing onto the stack），而移出数据叫做 出栈（popping off the stack）。\n栈中的所有数据都必须占用已知且固定的大小。\n在编译时大小未知或大小可能变化的数据，要改为存储在堆上。\n堆，Heap 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。\n内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。 这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。\n因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。\n想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。 如果有人来迟了，他们也可以通过询问来找到你们坐在哪。\n比较 入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。 相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。\n访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。\n继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。 在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。 从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。 出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。\n当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。\n","date":"2024-12-09T16:19:57+08:00","permalink":"https://codeSu97.github.io/p/heap-and-stack/","title":"堆与栈"},{"content":"所有权，ownership What is Ownership? - The Rust Programming Language (rust-lang.org)\n所有权规则 Rust 中的每一个值都有一个 所有者（owner） 值在任一时刻有且只有一个所有者 当所有者（变量）离开作用域，这个值将被丢弃，（例如，函数执行完） 变量作用域 变量的作用域从声明开始，到最后一次使用的地方结束\n1 2 3 4 5 { // s 在这里无效，它尚未声明 let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的 println!(\u0026#34;{}\u0026#34;, s); // 使用 s } // 此作用域已结束，s 不再有效 [!tip]\n当 s 进入作用域 时，它就是有效的 这一直持续到它 离开作用域 为止 内存与分配 在有 垃圾回收（garbage collector，GC）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。 在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。 从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。\n如果忘记回收了会浪费内存 如果过早回收了，将会出现无效变量 如果重复回收，这也是个 bug、 我们需要精确的为一个 allocate 配对一个 free。 Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。\n当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop。 在这里 String 的作者可以放置释放内存的代码，Rust 在结尾的 } 处自动调用 drop。\n1 2 3 4 5 6 { let s = String::from(\u0026#34;hello\u0026#34;); // 从此处起，s 是有效的 // 使用 s } // 此作用域已结束， // s 不再有效 [!warning] 在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）\n移动: 变量与数据交互的方式 在 Rust 中，多个变量可以采取不同的方式与同一数据进行交互。\n将变量 x 的整数值赋给 y：\n将 5 绑定到 x 将 x 的拷贝并绑定到 y 整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中 1 2 let x = 5; let y = x; 现在看看这个 String 版本： 第二行可能会生成一个 s1 的拷贝并绑定到 s2 上。不过，事实上并不完全是这样\n1 2 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; String 由三部分组成\n左侧所示： ptr，指向存放字符串内容内存的指针 len，长度，表示当前 String 内容使用了多少字符数 capacity，容量，表示当前 String 内容从分配器总共获取了多少字节的内存 capacity \u0026gt;= len，capacity 包括了为字符串内容预留的内存量，即使在字符串为空时也是如此 这一组数据存储在栈上，右侧则是堆上存放内容的内存部分 ![[1.学习/1.开发语言/Rust/assets/trpl04-01.svg|300]] 当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。 我们并没有复制指针指向的堆上数据。 ![[1.学习/1.开发语言/Rust/assets/trpl04-02.svg|300]]\n如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。 如果 Rust 这么做了，那么操作 s2 = s1 在堆上数据比较大的时候会对运行时性能造成非常大的影响。 ![[1.学习/1.开发语言/Rust/assets/trpl04-03.svg|300]]\n[!WANING] 当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。 复制，两个数据指针指向了同一位置。 这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。 这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。 两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。\n为了确保内存安全，在 let s2 = s1; 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。 这段代码不能运行：\n1 2 3 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{s1}, world!\u0026#34;); 你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0382]: borrow of moved value: `s1` --\u0026gt; kafka-producer/src/main.rs:16:15 | 14 | let s1 = String::from(\u0026#34;hello\u0026#34;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 15 | let s2 = s1; | -- value moved here 16 | println!(\u0026#34;{s1}, world!\u0026#34;); | ^^^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) help: consider cloning the value if the performance cost is acceptable | 15 | let s2 = s1.clone(); | ++++++++ For more information about this error, try `rustc --explain E0382`. warning: `kafka-producer` (bin \u0026#34;kafka-producer\u0026#34;) generated 1 warning error: could not compile `kafka-producer` (bin \u0026#34;kafka-producer\u0026#34;) due to 1 previous error [!TIP] 如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。 不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是叫做浅拷贝。 上面的例子可以解读为 s1 被 移动 到了 s2 中。 ![[1.学习/1.开发语言/Rust/assets/trpl04-04.svg|300]]\n这样就解决了我们的问题！因为只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕。\n另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。 因此，任何 自动 的复制都可以被认为是对运行时性能影响较小的。\n克隆: 变量与数据交互的方式 如果 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。\n这是一个实际使用 clone 方法的例子：\n1 2 3 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {s1}, s2 = {s2}\u0026#34;); 这段代码能正常运行，这里堆上的数据 确实 被复制了。 ![[1.学习/1.开发语言/Rust/assets/trpl04-03.svg|300]]\n拷贝: 只在栈上的数据 1 2 3 let x = 5; let y = x; println!(\u0026#34;x = {x}, y = {y}\u0026#34;); 但这段代码似乎似乎和上面的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。\n原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。 换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，可以不用管它。\nRust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。 如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。\nRust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。 如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。\n那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：\n所有整数类型，比如 u32。 布尔类型，bool，它的值是 true 和 false。 所有浮点数类型，比如 f64。 字符类型，char。 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。 所有权与函数 将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn main() { let s = String::from(\u0026#34;hello\u0026#34;); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走， // 没有特殊之处 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\u0026#34;{}\u0026#34;, some_string); } // 这里，some_string 移出作用域并调用 `drop` 方法。 // 占用的内存被释放 fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\u0026#34;{}\u0026#34;, some_integer); } // 这里，some_integer 移出作用域。没有特殊之处 当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。\n返回值与作用域 返回值也可以转移所有权。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn main() { let s1 = gives_ownership(); // gives_ownership 将返回值 // 转移给 s1 let s2 = String::from(\u0026#34;hello\u0026#34;); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中， // 它也将返回值移给 s3 } // 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 离开作用域并被丢弃 fn gives_ownership() -\u0026gt; String { // gives_ownership 会将 // 返回值移动给 // 调用它的函数 let some_string = String::from(\u0026#34;yours\u0026#34;); // some_string 进入作用域。 some_string // 返回 some_string // 并移出给调用的函数 // } // takes_and_gives_back 将传入字符串并返回该值 fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string 进入作用域 // a_string // 返回 a_string 并移出给调用的函数 } 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。\n虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。\n我们可以使用元组来返回多个值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (s2, len) = calculate_length(s1); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度 (s, length) } 但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 引用（references）。\n","date":"2024-12-09T12:46:41+08:00","permalink":"https://codeSu97.github.io/p/ownership/","title":"Rust学习笔记01 - 所有权"},{"content":" ODBC, Open Database Connectivity 是由 Microsoft 开发的数据库连接标准。 它允许应用程序使用标准化的接口访问不同的数据库系统。 特点 跨语言支持： ODBC 不是绑定于某种编程语言的，因此可以用于多种编程语言，包括 C、C++、Python 等。 平台依赖性： ODBC 原本是为 Windows 平台设计的，但也有跨平台版本，如 unixODBC 用于 Linux 系统。 使用方式： ODBC 通过 ODBC 驱动与数据库通信。驱动程序通常由数据库供应商提供，或者可以使用第三方驱动。 ODBC 需要在系统中配置数据源名称（DSN），通过 DSN 来标识和连接数据库。 使用 参考地址\n安装驱动 Ubuntu/Debian sudo apt-get install unixodbc unixodbc-dev odbcinst CentOS/RHEL sudo yum install unixODBC unixODBC-devel Windows 在 Windows 上，你可以通过安装 ODBC 数据源管理器和相应的数据库驱动来支持 ODBC。 配置数据源 Linux下，odbc依赖两个配置文件（以达梦8为例）\n配置驱动, /etc/odbcinst.ini 1 2 3 [DM8] Description = ODBC DRIVER FOR Dameng8 Driver = /data0/dm_db/dmdbms/drivers/odbc/libdodbc.so 两个属性，\nDescription，驱动说明 Driver，驱动文件 配置数据源, /etc/odbc.ini 1 2 3 4 5 6 7 8 [DM8] Description = DM ODBC DSN Driver = DM8 SERVER = localhost UID = SYSDBA PWD = SYSDBA TCP_PORT = 5236 LANGUAGE = CHINESE Description，数据源说明 Driver，驱动，要和 odbcinst.ini 中的 selection 保持一致 SERVER，连接的ip UID，账户名称 PWD，账户密码 TCP_PORT，连接端口 LANGUAGE，环境语言 测试 isql \u0026lt;DSN数据源名称\u0026gt; [UID [PWD]]\n","date":"2024-08-12T12:57:17+08:00","permalink":"https://codeSu97.github.io/p/odbc/","title":"ODBC"},{"content":"什么是IO IO，英文全称是Input/Output，即输入/输出。\n计算机角度的IO 我们常说的输入输出，比较直观的意思就是计算机的输入输出，计算机就是主体。\n冯.诺依曼结构，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。\n输入设备是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备； 输出设备是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。 鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，涉及计算机核心与其他设备间数据迁移的过程，就是IO。\n如磁盘IO，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是IO的本质。\n操作系统的IO 我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。\n操作系统负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过操作系统，才能做一些特殊操作，如磁盘文件读写、内存的读写等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。\n什么是用户空间？什么是内核空间?\n以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。\n我们应用程序是跑在用户空间的，它不存在实质的IO过程，真正的IO是在操作系统执行的。即应用程序的IO操作分为两种动作：IO调用和IO执行。IO调用是由进程（应用程序的运行态）发起，而IO执行是操作系统内核的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。\n操作系统的一次IO过程 应用程序发起的一次IO操作包含两个阶段：\nIO调用：应用程序进程向操作系统内核发起调用。 IO执行：操作系统内核完成IO操作。 操作系统内核完成IO操作还包括两个过程：\n准备数据：内核等待I/O设备准备好数据。 拷贝数据：将数据从内核缓冲区拷贝到用户进程缓冲区。 其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的IO过程包括以下几个步骤：\n应用程序进程向操作系统发起IO调用请求 操作系统准备数据，把IO外部设备的数据，加载到内核缓冲区 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区 IO模型 阻塞IO模型 (BIO, Blocking I/O) 假设应用程序的进程发起IO调用，但是如果内核的数据还没准备好的话，那应用程序进程就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为阻塞IO。\n阻塞IO比较经典的应用就是阻塞socket、Java BIO。 阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，浪费性能，可以使用非阻塞IO优化。 非阻塞IO模型 (NIO, Non-Blocking I/O) 如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下：\n非阻塞IO的流程如下：\n应用进程向操作系统内核，发起recvfrom读取数据。 操作系统内核数据没有准备好，立即返回EWOULDBLOCK错误码。 应用程序进程轮询调用，继续向操作系统内核发起recvfrom读取数据。 操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。 完成调用，返回成功提示。 非阻塞IO模型，简称NIO，Non-Blocking IO。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在性能问题，即频繁的轮询，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑IO复用模型，去解决这个问题。\n多路复用IO模型 (MIO, Multiplexing I/O) 既然NIO无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用，那不就好了嘛？\n在这之前，我们先来复习下，什么是文件描述符fd(File Descriptor),它是计算机科学中的一个术语，形式上是一个非负整数。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\nIO复用模型核心思路：系统给我们提供一类函数（如我们耳濡目染的select、poll、epoll函数），它们可以同时监控多个fd的操作，任何一个返回内核数据就绪，应用进程再发起recvfrom系统调用。\nselect 应用进程通过调用select函数，可以同时监控多个fd，在select函数监控的fd中，只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时应用进程再发起recvfrom请求去读取数据。\n非阻塞IO模型（NIO）中，需要N（N\u0026gt;=1）次轮询系统调用，然而借助select的IO多路复用模型，只需要发起一次询问就够了,大大优化了性能。\n但是呢，select有几个缺点：\n监听的IO最大连接数有限，在Linux系统上一般为1024。 select函数返回后，是通过遍历fdset，找到就绪的描述符fd。（仅知道有I/O事件发生，却不知是哪几个流，所以遍历所有流） 因为存在连接数限制，所以后来又提出了poll。与select相比，poll解决了连接数限制问题。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的socket。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，效率也会线性下降。\n因此经典的多路复用模型epoll诞生。\nepoll 为了解决select/poll存在的问题，多路复用模型epoll诞生，它采用事件驱动来实现，流程图如下：\nepoll先通过epoll_ctl()来注册一个fd（文件描述符），一旦基于某个fd就绪时，内核会采用回调机制，迅速激活这个fd，当进程调用epoll_wait()时便得到通知。这里去掉了遍历文件描述符的坑爹操作，而是采用监听事件回调的机制。这就是epoll的亮点。\nselect、poll、epoll的区别 select poll epoll 底层数据结构 数组 链表 红黑树和双链表 获取就绪的fd 遍历 遍历 事件回调 事件复杂度 O(n) O(n) O(1) 最大连接数 1024 无限制 无限制 fd数据拷贝 每次调用select，需要将fd数据从用户空间拷贝到内核空间 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间 epoll明显优化了IO的执行效率，但在进程调用epoll_wait()时，仍然可能被阻塞。\n信号驱动IO模型 (SDIO, Signal-driven I/O) 信号驱动IO不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（调用sigaction的时候建立一个SIGIO的信号），然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过SIGIO信号通知应用进程，数据准备好后的可读状态。应用用户进程收到信号之后，立即调用recvfrom，去读取数据。\n信号驱动IO模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，发现数据复制到应用缓冲的时候，应用进程还是阻塞的。回过头来看下，不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。\n异步IO模型 (AIO, Asynchronous I/O) 前面讲的BIO，NIO和SDIO，在数据从内核复制到应用缓冲的时候，都是阻塞的，因此都不算是真正的异步。AIO实现了IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是立即返回的不是处理结果，而是表示提交成功类似的意思。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程IO操作执行完毕。\n异步IO的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。日常开发中，有类似思想的业务场景：\n比如发起一笔批量转账，但是批量转账处理比较耗时，这时候后端可以先告知前端转账提交成功，等到结果处理完，再通知前端结果即可。\n阻塞、非阻塞、同步、异步IO划分 IO模型 BIO 同步阻塞 NIO 同步非阻塞 MIO 同步阻塞 SDIO 同步非阻塞 AIO 异步非阻塞 ","date":"2024-05-31T11:20:31+08:00","permalink":"https://codeSu97.github.io/p/io/","title":"I/O"},{"content":"对比 特性 String StringBuffer StringBuilder 可变性 不可变 可变 可变 线程安全 是（天然不可变） 是（synchronized方法） 否 性能 低（频繁创建对象） 中 高 内存分配 每次修改产生新对象 动态数组 动态数组 初始化容量 不可设置 默认16，可自定义 默认16，可自定义 JDK版本 1.0 1.0 1.5 使用场景 常量字符串、配置信息 多线程环境字符串操作 单线程环境字符串操作 实现分析 Java字符串体系结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 ┌───────────┐ ┌───────────────────────┐ │ String │ │ AbstractStringBuilder │ │-----------│ │-----------------------│ │ - value[] │\u0026lt;──────\u0026gt;│ + value[] │ │ - hash │ │ + count │ └────┬──────┘ └──────┬────────────────┘ │ │ ▼ ▼ ┌───────────────┐ ┌─────────────────┐ │ StringBuffer │ │ StringBuilder │ │---------------│ │-----------------│ │ + sync methods│ │ - non-sync │ └───────────────┘ └─────────────────┘ String 1 2 3 4 5 6 7 8 9 10 11 public final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { /** 实际存储数据的不可变数组 */ // jdk9 之前 private final char value[]; // jdk9 之后 private final byte[] value; /** 字符串的哈希码缓存 */ private int hash; // Default to 0 } 不可变性：value数组被声明为final，任何修改都会创建新对象 内存优化：从JDK9开始改用byte[]存储，支持LATIN1/UTF-16编码 常量池：字符串字面量自动加入常量池，减少重复创建 StringBuffer \u0026amp; StringBuilder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 abstract class AbstractStringBuilder { /** 动态数组存储字符数据 */ byte[] value; /** 当前已使用的字符数 */ int count; } public final class StringBuffer extends AbstractStringBuilder implements Serializable, CharSequence { // 所有方法添加synchronized关键字 @Override public synchronized StringBuffer append(String str) { super.append(str); return this; } } public final class StringBuilder extends AbstractStringBuilder implements Serializable, CharSequence { // 非线程安全实现 @Override public StringBuilder append(String str) { super.append(str); return this; } } 动态扩容：初始容量16（字符数） 线程安全：StringBuffer通过方法级同步保证线程安全（synchronized 关键字修饰） 继承抽象类：StringBuffer和StringBuilder都继承了AbstractStringBuilder 扩容分析，基于jdk17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 公开的容量确认方法 public void ensureCapacity(int minimumCapacity) { if (minimumCapacity \u0026gt; 0) { // 过滤无效参数 ensureCapacityInternal(minimumCapacity); // 调用内部扩容逻辑 } } // 内部扩容实现 private void ensureCapacityInternal(int minimumCapacity) { // 计算当前字符容量（字节长度 \u0026gt;\u0026gt; 编码位数） int oldCapacity = value.length \u0026gt;\u0026gt; coder; // 需要扩容的条件判断 if (minimumCapacity - oldCapacity \u0026gt; 0) { // 创建新数组并复制数据 value = Arrays.copyOf(value, newCapacity(minimumCapacity) \u0026lt;\u0026lt; coder); } } // 新容量计算逻辑 private int newCapacity(int minCapacity) { // 当前数组的字节长度 int oldLength = value.length; // 计算所需的最小字节长度（字符数 \u0026lt;\u0026lt; 编码位数） int newLength = minCapacity \u0026lt;\u0026lt; coder; // 需要扩展的字节数 int growth = newLength - oldLength; // 动态计算新容量（核心扩容算法） int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 \u0026lt;\u0026lt; coder)); // 默认扩展量 // 处理最大容量限制 if (length == Integer.MAX_VALUE) { throw new OutOfMemoryError(...); } // 返回字符容量（字节长度 \u0026gt;\u0026gt; 编码位数） return length \u0026gt;\u0026gt; coder; } 编码处理（coder字段）：\ncoder取值0（LATIN1）或1（UTF16BE）\n位移操作实现字节与字符转换：\n1 2 3 4 5 // 字节长度 → 字符容量 int characters = bytesLength \u0026gt;\u0026gt; coder; // 字符容量 → 字节长度 int bytes = characters \u0026lt;\u0026lt; coder; 扩容策略：\n1 2 3 4 5 6 7 ArraysSupport.newLength( int oldLength, // 当前数组长度（字节） int minGrowth, // 至少需要增长的量 int prefGrowth // 推荐增长量 ) int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 \u0026lt;\u0026lt; coder)); 实际扩容公式：新长度 = oldLength + max(minGrowth, prefGrowth) 默认扩展量计算：prefGrowth = oldLength + (2 \u0026lt;\u0026lt; coder) LATIN1编码时：+2字节（即扩容2字符） UTF16编码时：+4字节（即扩容2字符） 动态扩容流程：\n1 2 3 4 5 原始数组 → 计算最小需求 → ┌─满足需求 → 直接返回 └─需要扩容 → 计算新容量 → ├─超过限制 → 抛出OOM └─创建新数组 → 数据复制 性能优化点：\n延迟计算：只在需要扩容时进行计算 按需扩容：根据实际增长需求动态调整 位运算优化：使用位移代替乘除运算 扩容示例 假设原始状态：\n编码方式：UTF16（coder=1） 当前内容：\u0026ldquo;Hello\u0026rdquo;（5字符） 当前数组：char[16]（初始容量16字符） 执行append(\u0026ldquo;World!\u0026quot;)后：\n需要总字符数：5 + 6 = 11 当前容量16足够，无需扩容 继续追加数据直到需要17字符：\n计算最小字节需求：17 \u0026lt;\u0026lt; 1 = 34字节 当前数组长度：16 \u0026lt;\u0026lt; 1 = 32字节 计算growth = 34 - 32 = 2字节 计算prefGrowth：32 + (2 \u0026lt;\u0026lt; 1) = 36 新长度 = 32 + max(2, 36-32) = 32 + 4 = 36字节 新字符容量：36 \u0026gt;\u0026gt; 1 = 18字符 最终完成从16到18字符的扩容，实际扩容量是原始容量的1.125倍，而非传统的双倍扩容。\n性能测试 测试场景 10万次字符串追加操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class PerformanceTest { static final int LOOP_COUNT = 100_000; public static void main(String[] args) { // String测试 long start1 = System.nanoTime(); String s = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; LOOP_COUNT; i++) { s += \u0026#34;a\u0026#34;; } long duration1 = (System.nanoTime() - start1) / 1_000_000; // StringBuffer测试 long start2 = System.nanoTime(); StringBuffer sbuf = new StringBuffer(); for (int i = 0; i \u0026lt; LOOP_COUNT; i++) { sbuf.append(\u0026#34;a\u0026#34;); } long duration2 = (System.nanoTime() - start2) / 1_000_000; // StringBuilder测试 long start3 = System.nanoTime(); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; LOOP_COUNT; i++) { sb.append(\u0026#34;a\u0026#34;); } long duration3 = (System.nanoTime() - start3) / 1_000_000; System.out.printf(\u0026#34;String: %dms%n\u0026#34;, duration1); System.out.printf(\u0026#34;StringBuffer: %dms%n\u0026#34;, duration2); System.out.printf(\u0026#34;StringBuilder: %dms%n\u0026#34;, duration3); } } 测试结果 JDK17，Mac M1\n实现方式 耗时（ms） 内存分配（MB） String 4236 218 StringBuffer 12 0.5 StringBuilder 8 0.3 最佳实践 1. 选择策略 优先使用String：\n存储常量配置信息 作为方法参数传递 需要作为Map的Key使用时 使用StringBuilder：\n单线程环境下字符串拼接 SQL语句动态构建 日志消息组装 使用StringBuffer：\n多线程共享的字符串操作 全局日志缓冲区 需要同步修改的共享资源 2. 性能优化技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 预分配容量（减少扩容次数） StringBuilder sb = new StringBuilder(1024); // 链式调用优化 String result = new StringBuilder() .append(\u0026#34;Name: \u0026#34;).append(user.getName()) .append(\u0026#34;, Age: \u0026#34;).append(user.getAge()) .toString(); // 避免在循环中使用字符串拼接 // 错误示例： String output = \u0026#34;\u0026#34;; for (Data data : list) { output += data.getValue(); // 产生大量临时对象 } // 正确示例： StringBuilder output = new StringBuilder(); for (Data data : list) { output.append(data.getValue()); } 3. 特殊场景处理 多线程安全操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 使用StringBuffer的同步控制 class SharedResource { private StringBuffer buffer = new StringBuffer(); public void safeAppend(String str) { synchronized(buffer) { buffer.append(str); } } } // 或使用ThreadLocal private ThreadLocal\u0026lt;StringBuilder\u0026gt; localBuilder = ThreadLocal.withInitial(() -\u0026gt; new StringBuilder(256)); 常见误区 误区1：StringBuilder一定比StringBuffer快 真相：在单线程环境下确实如此，但差异通常在微秒级。实际开发中更应关注代码可读性 误区2：StringBuffer可以完全替代StringBuilder 线程开销：StringBuffer的同步锁在竞争激烈时会导致性能骤降 对象复用：StringBuffer实例作为类成员时可能被错误共享 进阶 1. JDK9优化改进 紧凑字符串：根据内容自动选择Latin-1或UTF-16编码 字符串去重：G1垃圾收集器的字符串去重功能（-XX:+UseStringDeduplication） 2. 内存泄漏防范 1 2 3 4 5 6 7 8 9 10 // 大字符串处理示例 void processHugeData() { String hugeString = readHugeFile(); // 1MB字符串 // 错误用法：截取小部分但保留大数组 String subStr = hugeString.substring(0,10); // 正确做法：显式创建新字符串 subStr = new String(hugeString.substring(0,10)); } 3. 字符串池机制 1 2 3 4 5 6 String s1 = \u0026#34;java\u0026#34;; String s2 = \u0026#34;java\u0026#34;; String s3 = new String(\u0026#34;java\u0026#34;); System.out.println(s1 == s2); // true（常量池引用） System.out.println(s1 == s3); // false（堆中新对象） 总结 基础原则：\n优先考虑不可变性 → String 单线程可变需求 → StringBuilder 多线程可变需求 → StringBuffer 性能关键点：\n避免不必要的字符串对象创建 预估容量减少扩容次数 警惕大字符串的内存驻留 发展趋势：\nValhalla项目的值类型（inline class）可能带来新的字符串实现 GraalVM的字符串优化策略 Project Loom对字符串操作的影响 通过合理选择字符串处理类，开发者可以在保证代码质量的同时，显著提升应用程序的性能表现。建议在关键路径代码中结合性能分析工具（如Async Profiler）进行针对性优化。\n","date":"2024-03-25T14:36:56+08:00","permalink":"https://codeSu97.github.io/p/string-stringbuffer-stringbuilder/","title":"String/StringBuffer/StringBuilder"},{"content":"在 Java 中，final 关键字是一个修饰符，用于定义变量、方法或类的不可变性或不可继承性。\n它的核心作用是限制修改或继承，从而增强代码的安全性、可读性和设计约束。\n作用范围 修饰变量 局部变量：必须在声明时或使用前赋值一次，之后不可修改。\n1 2 final int x = 10; // x = 20; // 编译错误：无法修改 final 变量 成员变量：必须在声明时、构造方法或初始化块中赋值一次。\n1 2 3 4 5 6 7 8 class MyClass { final int MAX_VALUE; // 非静态 final 变量 final static int MIN_VALUE = 0; // 静态 final 常量 public MyClass() { MAX_VALUE = 100; // 在构造方法中赋值 } } 引用类型变量\nfinal 修饰的是引用，而非对象本身。引用不可变，但对象内部状态可能可变。\n1 2 3 final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); // 允许修改对象内容 // list = new ArrayList\u0026lt;\u0026gt;(); // 编译错误：引用不可变 修饰方法 方法不可被重写：子类无法覆盖父类的 final 方法。\n1 2 3 4 5 6 7 8 9 10 class Parent { public final void print() { System.out.println(\u0026#34;Parent\u0026#34;); } } class Child extends Parent { // @Override // 编译错误：无法重写 final 方法 // public void print() { ... } } 设计意图：\n防止关键方法（如算法逻辑、安全校验）被子类意外修改。 修饰类 类不可被继承：\n1 2 3 4 final class StringUtils { // 工具类通常设计为 final // 工具方法... } // class ExtendedUtils extends StringUtils { } // 编译错误 设计意图：\n防止继承破坏类的内部逻辑（如 String、Integer 等不可变类）。 强制使用组合而非继承（如工具类）。 设计意义 安全性 常量定义：通过 final 变量定义全局常量（如配置参数），防止意外修改。 不可变对象：结合私有字段和 final 修饰符，实现线程安全的不可变对象。 1 2 3 4 5 6 7 8 9 10 public final class ImmutablePoint { private final int x; private final int y; public ImmutablePoint(int x, int y) { this.x = x; this.y = y; } // 只有 getter，没有 setter } 性能优化 编译优化：final 常量在编译时可能被直接替换为字面量（类似宏）。 JVM 优化：final 方法可能被内联（Inline）以提高执行效率。 设计约束 强制规范：通过 final 限制扩展或修改，明确类的职责（如工具类）。 防止破坏性继承：避免子类覆盖方法导致父类逻辑失效。 注意事项 引用类型变量 final 只能保证引用不变，但对象内部状态可能被修改（除非对象本身不可变）。\n1 2 final int[] arr = {1, 2, 3}; arr[0] = 100; // 允许修改数组内容 final 与不可变对象 final 是实现不可变对象的必要条件，但非充分条件。需结合以下条件：\n所有字段用 final 修饰。 字段为基本类型或不可变对象。 不对外暴露修改内部状态的方法（如 setter）。 final 参数 方法参数可以声明为 final，防止在方法内被意外修改（增强可读性）。\n1 2 3 public void process(final String input) { // input = \u0026#34;new value\u0026#34;; // 编译错误 } 强制约束机制 对变量的强制约束 编译阶段检查: 编译器会严格检查 final 变量的赋值次数。以下代码会直接编译失败：\n1 2 3 final int x; x = 10; x = 20; // 编译错误：Variable \u0026#39;x\u0026#39; might already have been assigned 运行时不可修改: 即使通过字节码操作（如直接修改 .class 文件），试图改变 final 变量的值也会导致 IllegalAccessError。\n（注：常规开发中无法绕过此限制。）\n对方法的强制约束 子类重写直接报错： 如果子类尝试重写父类的 final 方法，编译器会直接拒绝：\n1 2 3 4 5 6 7 8 class Parent { public final void doSomething() {} } class Child extends Parent { @Override // 编译错误：Cannot override the final method public void doSomething() {} } 对类的强制约束 禁止继承的编译检查： 任何尝试继承 final 类的行为都会导致编译错误\n1 2 final class UtilityClass {} class SubClass extends UtilityClass {} // 编译错误：Cannot inherit from final class 边界场景 反射修改 final 字段 理论上的可能性： 通过反射 API（如 Field.setAccessible(true)），可以修改 final 字段的值。\n1 2 3 4 5 6 7 8 9 10 11 class MyClass { final int value = 10; } public static void main(String[] args) throws Exception { MyClass obj = new MyClass(); Field field = MyClass.class.getDeclaredField(\u0026#34;value\u0026#34;); field.setAccessible(true); field.setInt(obj, 20); // 修改 final 字段的值 System.out.println(obj.value); // 输出 20（旧版本 Java 可能允许，新版默认禁止） } 实际限制：\n从 Java 12 开始，默认禁止通过反射修改 final 字段，会抛出 IllegalAccessException。 可通过 JVM 参数 \u0026ndash;add-opens java.base/java.lang=ALL-UNNAMED 绕过，但这属于破坏性操作，违背语言设计原则。 引用类型变量的内部可变性 final 仅约束引用，不约束对象内容：\n1 2 3 final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); // 合法操作：修改对象内部状态 // list = new ArrayList\u0026lt;\u0026gt;(); // 非法操作：修改引用 此时 final 强制的是引用不可变，但对象本身可能仍可变（除非对象自身设计为不可变，如 String）。\nfinal 是强制的？ 语言规范定义 Java 语言规范明确要求 final 的约束必须被遵守，否则代码无法通过编译（JLS §4.12.4）。\n编译器和运行时的双重保障 编译器：静态检查语法合法性。 JVM：运行时内存模型保证 final 字段的初始化安全（如 final 字段的写入对其他线程可见）。 设计哲学 final 的强制性是为了保障代码的可靠性和一致性。例如：\n不可变对象（String）依赖 final 的强制约束。 工具类（如 Math）通过 final 类禁止继承，确保方法逻辑不被篡改。 ","date":"2024-03-21T16:58:52+08:00","permalink":"https://codeSu97.github.io/p/java-final/","title":"如何理解 Final 关键字？"},{"content":"什么是 Spring IoC? Spring IoC（Inversion of Control，控制反转）是 Spring 框架的核心机制，其核心思想是将对象的创建、依赖管理和生命周期交给容器统一控制，而非由开发者手动通过 new 创建对象。\n通过 IoC，代码的耦合度降低，程序的灵活性和可维护性显著提高。\n例如，如果一个用户服务需要数据库连接，容器会确保数据库连接被正确注入，而无需手动创建。\n负责管理对象的生命周期和依赖关系。 它通过依赖注入（Dependency Injection, DI）来实例化、配置和组装被称为“bean”的对象。 配置元数据可以是 XML、Java 注解或 Java 代码，增强了系统的模块化和灵活性. 依赖查找 价值 灵活应对运行时需求：有些依赖需要根据实时条件获取，比如按不同场景或配置，动态选择不同实现，这时直接注入一个固定 bean 可能不够灵活，需要主动查找。 工具或框架类的特殊需求：一些工具类或公共组件并不便于被注入到特定对象中，反而使用依赖查找更符合设计。比如在某些自定义 Starter 或底层框架中，可能会在初始化流程中需要访问容器本身。 在特定场景临时获取 bean：有时你需要延迟获取某些依赖，或想在调用时才加载/初始化（如懒加载），这时依赖查找也比提前注入更合适。 实现 通过 BeanFactory 基础接口 1 2 3 4 5 6 7 8 9 10 11 // 1. 创建容器 BeanFactory factory = new XmlBeanFactory(new ClassPathResource(\u0026#34;applicationContext.xml\u0026#34;)); // 2. 查找 Bean（按名称） UserService userService = (UserService) factory.getBean(\u0026#34;userService\u0026#34;); // 3. 按类型查找（Spring 5+） UserService userService = factory.getBean(UserService.class); // 4. 按注解查找 UserService userService = factory.getBeansWithAnnotation(UserService.class); 特点：\n最原始的 IoC 容器接口 需要手动处理类型转换 适用于简单场景（现代项目更常用 ApplicationContext） 通过 ApplicationContext 接口 1 2 3 4 5 6 7 8 9 10 11 // 1. 初始化容器（XML 配置） ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); // 2. 按名称查找 UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); // 3. 按类型查找（推荐） UserService userService = context.getBean(UserService.class); // 4. 按名称+类型查找（无需强制转换） UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); 特点：\n企业级容器接口，支持事件、国际化等扩展功能 推荐使用 getBean(Class\u0026lt;T\u0026gt;) 避免类型转换错误 通过 ObjectProvider（延迟/可选依赖查找） 1 2 3 4 5 6 7 8 9 10 11 12 // 注入 ObjectProvider（Spring 4.3+） @Autowired private ObjectProvider\u0026lt;UserService\u0026gt; userServiceProvider; // 延迟获取 Bean UserService userService = userServiceProvider.getIfAvailable(); // 处理多个候选 Bean UserService userService = userServiceProvider.getIfUnique(); // 显式指定条件（如通过 @Qualifier 的变体） UserService userService = userServiceProvider.getObject(); 特点：\n支持延迟加载和可选依赖 解决 NoUniqueBeanDefinitionException 问题 结合 @Lazy 注解可实现懒加载 通过 @Autowired + ApplicationContextAware 1 2 3 4 5 6 7 8 9 10 11 12 13 @Component public class MyBean implements ApplicationContextAware { private ApplicationContext context; @Override public void setApplicationContext(ApplicationContext context) { this.context = context; } public void doSomething() { UserService userService = context.getBean(UserService.class); } } 特点：\n将容器上下文注入到 Bean 中 适用于需要动态查找的场景 通过注解扫描（基于 @ComponentScan） 1 2 3 4 5 6 7 8 9 @Configuration @ComponentScan(\u0026#34;com.example\u0026#34;) public class AppConfig {} // 初始化容器 ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // 查找带有 @Component 的 Bean UserRepository repo = context.getBean(UserRepository.class); 特点：\n结合组件扫描自动注册 Bean 隐式依赖查找的基础 通过 JNDI 查找（传统方式） 1 2 3 4 5 // 在 Spring XML 配置中声明 JNDI 资源 \u0026lt;jee:jndi-lookup id=\u0026#34;dataSource\u0026#34; jndi-name=\u0026#34;java:comp/env/jdbc/mydb\u0026#34;/\u0026gt; // 通过容器查找 DataSource dataSource = (DataSource) context.getBean(\u0026#34;dataSource\u0026#34;); 特点：\n适用于 Java EE 环境整合 现代项目更多使用 @Bean 配置数据源 通过静态方法（Web 环境专用） 1 2 3 4 5 6 // 获取 WebApplicationContext（如 Servlet 环境） WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext); // 查找 Bean UserService userService = context.getBean(UserService.class); 对比 方式 适用场景 优点 缺点 BeanFactory 简单容器操作 轻量级 功能有限 ApplicationContext 企业级应用（主流选择） 功能全面 稍重 ObjectProvider 处理延迟/可选依赖 解决多候选 Bean 问题 需要 Spring 4.3+ @Autowired + 上下文 动态查找场景 灵活 侵入性强 注解扫描 自动装配的基础 简化配置 需配合组件扫描 推荐实践：\n优先使用依赖注入（被动获取） 仅在需要动态获取时使用依赖查找（如工厂模式、插件化架构） 现代项目首选 ApplicationContext.getBean() 或 ObjectProvider 依赖注入 依赖注入（Dependency Inject, DI）是 Spring 框架的核心功能，体现了控制反转（IoC）的设计原则。通过 DI，Spring IoC 容器负责创建和管理 bean 的依赖，并将这些依赖注入到目标 bean 中。注入方式包括：\n构造函数注入：通过构造函数传递依赖。 优点 使用 final 关键字，不可变，对象创建后，依赖不可变 依赖关系明确，显著降低了组件之间的耦合性，使代码更易于测试和维护。 易于测试，可以直接传递模拟依赖 Spring 会在启动时确保所有依赖都已注入，避免运行时空指针异常 缺点 如果依赖多，构造函数可能过长 缺乏灵活性，创建后无法更改依赖 setter 注入：通过 setter 方法设置依赖。 优点 灵活，可在对象创建后设置或更改依赖 适合可选依赖，可能不总是需要的 易于扩展，如果后期需要添加新依赖，只需添加新的 setter 方法 缺点 对象可变，可能导致状态不一致 未设置依赖，导致空指针异常 字段注入：通过注解（如 @Autowired）直接在字段上注入依赖，Spring 会使用反射机制在对象创建后自动设置字段的值。 优点 代码简洁，无需编写 setter 或构造函数 使用简单，易于实现 Spring 会在启动时确保依赖注入，减少手动配置 缺点 与 Spring 框架紧密耦合，增加依赖 依赖关系不显眼，测试可能更复杂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class MyService { private final MyDependency dependency; // 构造函数注入 @Autowired public MyService(MyDependency dependency) { this.dependency = dependency; } public void doSomething() { dependency.execute(); } } public class MyService { private MyDependency dependency; // Setter 注入 @Autowired public void setDependency(MyDependency dependency) { this.dependency = dependency; } } public class MyService { // 字段注入 @Autowired private MyDependency dependency; } 依赖来源 依赖对象的来源主要就是 Spring IoC 容器（BeanFactory 或 ApplicationContext）本身。容器根据 XML、注解、Java Config 等方式加载 bean 定义并实例化这些对象，管理它们的生命周期，然后通过依赖注入或依赖查找将它们提供给应用使用。\n自定义 Bean 自己编写并交给 Spring 管理的类，比如带有 @Component、@Service、@Repository、@Controller 等注解的类，或者在 XML/JavaConfig 中显式声明的 Bean。 容器内建的 Bean Spring 容器在启动或运行过程中，会自动创建并维护一些基础设施类或辅助功能类，供框架内部或用户使用 比如 ApplicationContext 自身、Environment、ResourceLoader、ConversionService、MessageSource、BeanFactoryPostProcessor、BeanPostProcessor 以及各种内部用来处理注解、AOP、事务等功能的 Bean Environment environment = applicationContext.getBean(Environment.class); 容器内建的依赖，（依赖注入） 指的是那些不一定以 Bean 形式出现，但由容器提供、可被注入或查找的依赖。例如： BeanFactory / ApplicationContext：在使用 @Autowired 时可以直接注入 ApplicationContext； 环境变量、配置属性：通过 @Value(\u0026quot;${property}\u0026quot;) 或 Environment 对象获取； 事件发布器（ApplicationEventPublisher）、任务调度器（TaskScheduler）等容器级别的基础依赖。 这些依赖在某些情况下也会以 Bean 的形式出现，但总体上它们属于 Spring 内部或与运行环境强相关的内容，是容器层面“提供”的依赖。 元信息 Bean 的标识 包括 Bean 名称（id 或 name）、Bean 所对应的类名、别名等。 Bean 的作用域（Scope） 常见的有 singleton、prototype、request、session 等。 用于决定容器如何缓存或创建 Bean 实例。 依赖注入信息 包括构造器参数、Setter 方法注入、字段注入等。 哪些依赖是必须的？哪些是可选的？ 生命周期回调（Lifecycle callbacks）： 初始化方法（init-method 或 @PostConstruct）、 销毁方法（destroy-method 或 @PreDestroy）等 条件或环境： 比如 @Conditional 注解可以决定是否加载某个 Bean； 或者 @Profile 控制在特定环境（dev, test, prod）下是否启用某些 Bean。 其他配置： 是否使用 AOP、事务等功能； 是否启用延迟加载（lazy-init）； 是否是自动装配（autowire），等等。 配置元信息 Bean 定义配置 基于 XML 文件 基于 Properties 文件 基于 Java 注解 基于 Java API IoC 容器配置 基于 XML 文件 基于 Java 注解 基于 Java API 外部化属性配置 基于 Java 注解，@Value @Autowired 和 @Resource 的区别 注入机制 @Autowired 是基于类型的注入。 它会查找与字段或参数类型匹配的 bean。例如，如果一个字段是 MyDependency 类型，Spring 会注入所有实现 MyDependency 接口的 bean。 @Resource 是基于名称的注入。 它会根据字段名称或显式指定的名称查找 bean。例如，如果字段名为 dependency，它会查找名为 \u0026ldquo;dependency\u0026rdquo; 的 bean。 @Resource 还可以用于注入资源（如 DataSource），而不仅仅是 bean，这在某些复杂场景下可能更灵活。 是否必需 @Autowired 默认是必需的。如果找不到匹配的 bean，Spring 会抛出异常。但你可以通过 required = false使它可选。 @Resource 默认是可选的。如果找不到匹配的 bean，字段会保持为 null，无需额外配置。 标准与框架 @Autowired 是 Spring 框架专有的注解，适合深度集成 Spring 的项目。 @Resource 是 Java 标准的一部分（JSR-250），在 Java EE 环境中也常用，适合希望减少框架依赖的项目。 使用场景 如果你需要基于类型的注入，且依赖是必需的，推荐使用 @Autowired。例如： 1 2 3 4 public class MyService { @Autowired private MyDependency dependency; // 注入类型为 MyDependency 的 bean } 如果你需要基于名称的注入，或依赖是可选的，推荐使用 @Resource。例如： 1 2 3 4 public class MyService { @Resource(name = \u0026#34;specificDependency\u0026#34;) private MyDependency dependency; // 注入名为 \u0026#34;specificDependency\u0026#34; 的 bean } ","date":"2024-03-17T14:44:31+08:00","permalink":"https://codeSu97.github.io/p/spring-learning-02/","title":"Spring学习笔记02 - Spring IoC"},{"content":" Spring Framework 为基于 Java 的现代企业应用程序提供了一个全面的编程和配置模型，适用于任何类型的部署平台。\nSpring 的一个关键要素是应用层面的基础架构支持：Spring 专注于企业应用程序的 “管道”，因此团队可以专注于应用程序级的业务逻辑，而无需与特定部署环境进行不必要的绑定。\n― Spring Framework, spring.io Spring Framework 有哪些核心模块? spring-core Spring 基础的API模块，如资源管理、泛型处理 提供框架的基本工具类和核心工具，如依赖注入（DI）的实现、IoC 容器的基本功能等。 spring-beans 用于管理和配置应用程序中的 bean，Bean对象的创建、生命周期管理，依赖查找、依赖注入 sprign-context 事件驱动、注解驱动、模块驱动等 建立在 Core 和 Beans 之上，提供类似于 JNDI 的功能，以及国际化、事件传播、资源加载等功能。它类似于一个轻量级的容器，便于集成不同的框架。 spring-expression Spring 表达式 语言模块 提供强大的表达式语言支持，可以在 XML 或注解中动态计算值，增强了配置和动态功能的灵活性。 spring-aop Spring AOP 处理，如动态代理、AOP字节码提升 实现面向切面编程的支持，通过切面（Aspect）来定义横切关注点，如日志、安全、事务等，从而实现与业务逻辑的分离。这一模块使得应用程序能够在不修改核心业务代码的情况下添加额外的行为。 spring-jdbc 封装了 JDBC 操作，提供了模板化方法来简化数据库访问和异常处理，减少了样板代码。 spring-orm 为主流 ORM 框架（如 Hibernate、JPA、MyBatis 等）提供支持，简化数据持久化操作的配置和集成。 spring-tx 提供声明式事务管理，帮助开发者在不同的数据访问技术之间保持一致的事务管理策略。 spring-web 为开发 web 应用提供基本的支持，包括 WebSocket、Multipart 文件上传、以及 HTTP 请求和响应处理。 spring-webmvc 实现了 Model-View-Controller (MVC) 设计模式，提供了一整套用于构建基于请求-响应模型的 Web 应用程序的组件。通过该模块，可以轻松构建松耦合、可测试的 Web 应用。 spring-test 提供对 Spring 应用的单元测试和集成测试的支持，包括对 JUnit 和 TestNG 的集成，帮助开发者在不依赖外部服务器的情况下模拟和测试应用的行为，确保代码质量和稳定性。 优势 模块化和灵活性：Spring 允许开发者选择需要的组件，支持 XML 和基于注解的配置，适合各种项目需求。 轻量级和便携性：无需繁重的应用服务器，可以在像 Tomcat 这样的 servlet 容器上运行，降低资源占用。 依赖注入和控制反转（IoC）：促进组件松耦合，易于测试和扩展。 面向切面编程（AOP）：模块化横切关注点，如日志、安全和事务管理，提升代码复用性。 丰富的生态系统：提供数据访问、Web 服务、安全等多个模块，满足企业级应用需求。 易于测试：依赖注入功能简化测试数据注入，确保应用可靠性。 一致的 API：为异常处理、事务管理等提供统一接口，简化开发。 长期维护和可靠性：Spring 历史悠久，持续更新，适合长期项目。 不足 学习曲线陡峭：对于新手或不熟悉 DI 和 AOP 的开发者，学习成本较高。 复杂性：功能丰富可能导致项目复杂，尤其对小型项目不必要。 配置冗长：尽管注解减少了 XML 配置，但某些设置仍可能繁琐。 安全问题：Spring 提供安全特性，但配置不当可能导致如跨站脚本攻击（XSS）等漏洞，需额外注意。 性能开销：抽象层可能引入轻微性能开销，但通常对大多数用例影响不大。 ","date":"2024-03-10T19:49:27+08:00","permalink":"https://codeSu97.github.io/p/spring-learning-01/","title":"Spring学习笔记01 - Spring Framework"},{"content":"在 Java 中，字符串（String）被设计成不可变对象，这是语言设计中的一个重要决策。这种设计的核心原因是为了安全性、性能优化和简化程序逻辑。以下是具体原因和解释：\n不可变性的定义 不可变对象（Immutable Object）是指对象的状态在创建后不能被修改。对于 String 来说：\n任何对字符串内容的修改（如拼接、替换）都会生成新的字符串对象，原对象保持不变。\n例如：\n1 2 String s1 = \u0026#34;hello\u0026#34;; String s2 = s1.concat(\u0026#34; world\u0026#34;); // 生成新对象 \u0026#34;hello world\u0026#34;，s1 仍是 \u0026#34;hello\u0026#34; 为什么 String 要设计成不可变？ 线程安全性 不可变对象天然线程安全。多个线程可以共享同一个字符串对象，无需担心数据被意外修改，从而避免同步开销。 如果 String 可变，在多线程环境中必须通过同步机制（如 synchronized）保证一致性，性能会显著下降。 哈希码缓存（Hash Caching） String 是 HashMap、HashSet 等集合的常用键（Key）。\n不可变性保证字符串的哈希码（hashCode()）在创建时即可计算并缓存，后续使用直接复用，无需重复计算。\n1 2 String key = \u0026#34;user_id\u0026#34;; int hash = key.hashCode(); // 计算一次后缓存，后续直接使用 如果 String 可变，修改内容会导致哈希码变化，破坏哈希表的正确性（例如键的哈希码改变后无法找到原值）。\n字符串常量池优化 JVM 通过字符串常量池（String Pool） 复用字符串，减少内存开销。\n如果 String 可变，常量池中的字符串可能被意外修改，导致其他引用该字符串的代码出错。\n1 2 3 String s1 = \u0026#34;hello\u0026#34;; // 放入常量池 String s2 = \u0026#34;hello\u0026#34;; // 复用常量池中的 \u0026#34;hello\u0026#34; // 若 s1 被修改为 \u0026#34;hi\u0026#34;，s2 也会被影响（但实际不可变，所以安全） 安全性 字符串常用于敏感操作（如文件路径、数据库连接、网络请求、类加载等）。\n不可变性防止恶意代码篡改字符串内容。例如：\n1 2 3 // 假设 String 可变，攻击者可能修改路径指向恶意文件 String filePath = \u0026#34;/safe/path/config.txt\u0026#34;; // 如果 filePath 被修改为 \u0026#34;/hack/path\u0026#34;，程序会读取错误文件 类加载机制 JVM 使用字符串表示类名、方法名、包名等元数据。 如果类名（字符串）被修改，可能导致加载错误的类，破坏程序逻辑。 设计哲学与性能权衡 不可变设计简化了字符串的实现和优化。例如： 子字符串（substring()） 可以安全地共享原始字符数组（仅调整偏移量），无需复制数据。 编译器和 JVM 的优化（如常量折叠、内联优化）依赖不可变性。 尽管字符串不可变会在频繁修改时产生性能问题（如大量拼接操作），但 Java 提供了 StringBuilder 和 StringBuffer 作为补充，平衡灵活性与效率。 如何实现不可变性？ Java 通过以下机制保证 String 不可变：\n类声明为 final：禁止通过继承覆盖方法。 内部字符数组 private final char[] value：外部无法直接访问或修改。 所有修改操作返回新对象：如 concat()、replace() 等。 不可变性的核心优势 优势 说明 线程安全 无需同步，天然支持多线程共享。 哈希码缓存 提升哈希表性能，避免重复计算。 字符串常量池 减少内存占用，复用相同字符串。 安全性 防止敏感数据被篡改。 简化优化 编译器、JVM 可基于不可变性进行深度优化（如常量折叠、子字符串共享）。 示例：不可变性的实际影响 1 2 3 4 5 6 7 String s1 = \u0026#34;hello\u0026#34;; String s2 = s1; s1 = s1 + \u0026#34; world\u0026#34;; // 生成新对象 \u0026#34;hello world\u0026#34;，s1 指向新对象，s2 仍指向 \u0026#34;hello\u0026#34; // 如果 String 可变，s2 的内容会被修改，但实际不可变，s2 保持原值 System.out.println(s1); // \u0026#34;hello world\u0026#34; System.out.println(s2); // \u0026#34;hello\u0026#34; 常见疑问 不可变是否导致性能问题？ 是，但 Java 提供了 StringBuilder（非线程安全）和 StringBuffer（线程安全）来优化频繁修改字符串的场景。\n例如：循环拼接字符串时，优先使用 StringBuilder：\n1 2 3 4 5 StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { sb.append(i); // 避免生成大量中间对象 } String result = sb.toString(); 为什么其他语言（如 Python）的字符串也是不可变的？ 出于类似的理由：安全性、性能优化（如驻留机制）和简化语言设计。 结论 Java 将 String 设计为不可变，是为了在安全性、性能、并发性之间取得平衡。\n这种设计虽然牺牲了部分灵活性，但通过配套工具类（如 StringBuilder）弥补了这一缺陷，成为 Java 生态稳定高效的重要基石。\n","date":"2024-01-21T16:15:09+08:00","permalink":"https://codeSu97.github.io/p/java-string-immutable/","title":"为什么 String 会设计成不可变？"},{"content":"Write once, run anywhere “一次编写，到处运行”说的是Java语言跨平台的特性，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编写，到处运行这样的效果。\n严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。“一次编写，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。Java虚拟机和DOS类似，相当于一个供程序运行的平台。\n程序从源代码到运行的三个阶段：编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第一次编译。 .class 文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。\n“到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。需要强调的一点是，java并不是编译机制，而是解释机制。Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样是虚拟机的一个构成部分。\nJava 是解释运行吗？ 答案是 不是\nJava 是如何编译的？ 编译阶段： Java源代码（.java）通过javac编译器 提前编译 为平台无关的字节码（.class） 这一步是传统的AOT（Ahead-Of-Time, 预先编译，编译在程序运行前完成）编译，生成中间代码而非机器码 运行时阶段： 解释执行： JVM（如HotSpot）首先逐行解释执行字节码（.class）。 JIT编译： （Just in time，即时编译）对于频繁执行的代码（热点代码，方法级代码），JVM触发JIT编译器（如C1/C2）将其编译为本地机器码，大幅提升性能，属于运行时动态优化。 ","date":"2024-01-20T15:35:28+08:00","permalink":"https://codeSu97.github.io/p/write-once-run-anywhere/","title":"如何理解Java的 “一次编写，到处运行”"},{"content":"certbot简介 本质上来说，certbot 就是一个 ACME client，这也是 Let’s Encrypt 官网推荐的签发证书的方式，适用于对自己的 domain 具有 shell 访问能力的情况，使用所谓的 ACME 协议来自动化的签发证书，很大程度上简化了证书签发的步骤。\n安装步骤 以Ubuntu为例，安装certbot\n1 2 sudo apt-get update sudo apt-get install certbot python3-certbot-nginx 为nginx生成证书 1 sudo certbot --nginx -d www.yourdomain.com 将www.yourdomain.com替换为您的实际域名。Certbot将自动配置Nginx以使用生成的证书。\n证书将在90天后过期，因此我们需要设置自动续期。Certbot包含一个名为certbot renew的命令，用于检查证书是否需要更新，如果需要，则自动更新它们。\n自动续期 为了设置自动续期，我们将创建一个定时任务（cron job）。\n1 2 3 4 crontab -e # 每月1号执行一次 0 0 1 */1 * /usr/bin/certbot renew --quiet ","date":"2023-12-19T20:15:06+08:00","image":"https://codeSu97.github.io/p/certbot%E5%85%8D%E8%B4%B9%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/certbot_hu_273039a4fe2d7a20.png","permalink":"https://codeSu97.github.io/p/certbot%E5%85%8D%E8%B4%B9%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/","title":"Certbot免费申请SSL证书"},{"content":"在GitHub或者GitLab提交超过50M的大文件的时候，无法上传 什么是Git LFS Git 是分布式版本控制系统，这意味着在克隆过程中会将仓库的整个历史记录传输到客户端。\n对于包涵大文件（尤其是经常被修改的大文件）的项目，初始克隆需要大量时间，因为客户端会下载每个文件的每个版本。\nGit LFS（Large File Storage）是由 Atlassian, GitHub 以及其他开源贡献者开发的 Git 扩展，它通过延迟地（lazily）下载大文件的相关版本来减少大文件在仓库中的影响，具体来说，大文件是在 checkout 的过程中下载的，而不是 clone 或 fetch 过程中下载的（这意味着你在后台定时 fetch 远端仓库内容到本地时，并不会下载大文件内容，而是在你 checkout 到工作区的时候才会真正去下载大文件的内容）。\n参考文献 Atlassian官方LFS文章 ","date":"2023-01-12T15:41:12+08:00","permalink":"https://codeSu97.github.io/p/gitlfs/","title":"Git Lfs"},{"content":"iptables 是什么 iptables 是运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的处理和转发。iptables只支持处理ipv4数据包，对于ipv6数据包，则需要ip6tables。\niptables命令介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 # iptables --help iptables v1.4.21 Usage: iptables -[ACD] chain rule-specification [options] iptables -I chain [rulenum] rule-specification [options] iptables -R chain rulenum rule-specification [options] iptables -D chain rulenum [options] iptables -[LS] [chain [rulenum]] [options] iptables -[FZ] [chain] [options] iptables -[NX] chain iptables -E old-chain-name new-chain-name iptables -P chain target [options] iptables -h (print this help information) iptables基本命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --append -A chain 添加一个规则到链的末尾 --check -C chain 检查某一条链是否存在 --delete -D chain 删除匹配的链 --delete -D chain rulenum 删除指定链的某一条规则 --insert -I chain [rulenum] 根据给出的规则序号向所选链中插入一条或更多规则。所以，如果规则序号为1， 规则会被插入链的头部。这也是不指定规则序号时的默认方式。 --replace -R chain rulenum 修改指定链中的某一条规则 --list -L [chain [rulenum]] 列出指定链中的规则 --list-rules -S [chain [rulenum]] 打印出指定链中的规则 --flush -F [chain] 删除指定链中的规则 --zero -Z [chain [rulenum]] 把指定链，或者表中的所有链上的所有计数器清零 --new -N chain 创建一条用户自定义链 --delete-chain -X [chain] 删除一条用户自定义链 --policy -P chain target 该表某条链的策略 --rename-chain -E old-chain new-chain 修改链的名称(只有用户自定义链的名称可以被修改） iptables选项参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [!] --protocol -p proto 规则或者包检查的协议。指定协议可以是tcp、udp、icmp中的一个或全部，也可以是数值，代表这些协议中的某一个。 当然也可以使用在/etc/protocols中定义的协议名。在协议名前加\u0026#39;!\u0026#39;表示相反的规则。数字0相当于all。Protocol all会匹配所有协议，而且这是缺省的选项。在和check命令结合时，all可以不被使用 [!] --source -s address[/mask][...] 指定源地址，可以是主机名、网络名或IP地址。mask说明可以是网络掩码或清楚的数字。标志--src是这个选项的简写。 [!] --destination -d address[/mask][...] 指定目标地址。标志--dst是这个选项的简写 --jump -j target 执行指定的动作 --goto -g chain 跳转到指定的链 --match -m match 扩展匹配 --numeric -n 以数字的形式显示IP地址和端口 [!] --in-interface -i input name[+] 匹配由指定网络接口进入的数据包 [!] --out-interface -o output name[+] 由指定接口发出的数据包 [!] --fragment -f 这意味着在分片的包中，规则只询问第二及以后的片 --exact -x 扩展数字。显示包和字节计数器的精确值，代替用K、M、G表示的约数。这个选项仅能用于-L选项 --line-numbers 当列表显示规则时，在每个规则前面加上行号，与该规则在链中的位置相对应。 1. 针对 tcp 的扩展 当--protocol tcp被指定，且其他匹配的扩展未被指定时，这些扩展被装载。它提供以下选项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 --source-port [!] [port[:port]] 源端口或端口范围指定，也可以使用服务名或端口号。如果使用端口范围，若首端口号忽略则默认为0，若尾端口号忽略则 默认为65535。这个选项可以简写为--sport --destionation-port [!] [port:[port]] 目标端口或端口范围指定。这个选项可以使用--dport别名来代替 --tcp-flags [!] mask comp 匹配指定的TCP标记。第一个参数是我们要检查的标记，一个用逗号分开的列表，第二个参数是用逗号分开的标记表,是必须 被设置的。标记如下：SYN ACK FIN RST URG PSH ALL NONE。例如我们有如下这条命令： iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN 上面这条命令只匹配那些SYN标志被设置而ACK、FIN和RST标记没有被设置的包 [!] --syn 只匹配那些设置了SYN位而清除了ACK和FIN位的TCP包。这些包用于TCP连接初始化时发出请求。例如，大量的这种包进入一个 接口发生堵塞时会阻止进入的TCP连接，而出去的TCP连接不会受到影响。这等于：--tcp-flags SYN,RST,ACK SYN --tcp-option [!] number 匹配设置了TCP选项的数据包 2. 针对 udp 的扩展 当--protocol udp被指定，且其他匹配的扩展未被指定时，这些扩展被装载。它提供以下选项：\n1 2 --source-port [!] [port:[port]] 源端口或端口范围指定 --destionation-port [!] [port:[port]] 目标端口或端口范围指定 3. 针对 ICMP 的扩展 当--protocol icmp被指定，且其他匹配的扩展未被指定时，这些扩展被装载。它提供以下选项：\n1 --icmp-type [!] typename 这个选项允许指定ICMP类型，可以是一个数值型的ICMP类型，或者是某个由命令iptables -p icmp -h所显示的ICMP类型名 4. 针对 mac 的扩展 1 --mac-source [!] address 匹配物理地址。注意它只对来自以太设备并进入PREROUTING、FORWORD和INPUT链的包有效。 5. 针对 limit 的扩展 1 2 --limit rate 最大平均匹配速率：可赋的值有\u0026#39;/second\u0026#39;, \u0026#39;/minute\u0026#39;, \u0026#39;/hour\u0026#39;, or \u0026#39;/day\u0026#39;这样的单位，默认是3/hour --limit-burst number 待匹配包初始个数的最大值:若前面指定的极限还没达到这个数值,则概数字加1.默认值为5 iptables targets 介绍 iptables的-j选项后面对应的是要执行的target。其中有些target具有一些扩展选项，下面我们会一并介绍：\n1. ACCEPT 表示接收匹配的数据包\n2. DROP 表示丢弃匹配的数据包\n3. REJECT 作为对匹配的包的响应，返回一个错误的包：其他情况下与DROP 相同\n此目标只适用于INPUT、FORWORD和OUTPUT，和调用这些的用户自定义链。\n1 2 3 4 5 6 --reject-with type type可以是icmp-net-unreachable、icmp-host-unreachable、icmp-port-nreachable、icmp-proto-unreachable、 icmp-net-prohibited或者icmp-host-prohibited，该类型会返回相应的ICMP错误信息（默认是port-unreachable） --echo-reply 它只能用于指定ICMP ping包的规则中，生成ping的回应 --tcp-reset 可以用于在INPUT链中,或自INPUT链调用的规则，只匹配TCP协议：将回应一个TCP RST包。 4. REDIRECT 表示重定向匹配的数据包，只适用于nat表的PREROUTING和OUTPUT，和只调用它们的用户自定义链。它修改包的目标IP地址来发送包到机器自身（本地生成的包被安置为地址127.0.0.1）\n1 --to-ports [port-port] 指定使用的目的端口或端口范围：不指定的话，目标端口不会被修改。只能用于指定了-p tcp 或 -p udp的规则。 iptables常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 新增规则# 指定 ip 访问指定端口 iptables -I INPUT -s \u0026lt;ip\u0026gt; -p tcp -m tcp --dport \u0026lt;port\u0026gt; -j ACCEPT # 允许所有ip访问指定端口 iptables -I INPUT -p tcp -m tcp --dport \u0026lt;port\u0026gt; -j ACCEPT # 查看所有规则 iptables -n -L # 查看所有规则，带 序号 iptables -n -L --line-number # 删除规则# 删除 INPUT 的 序号为 1 的规则 iptables -D INPUT 1 ","date":"2022-12-28T21:15:49+08:00","permalink":"https://codeSu97.github.io/p/iptables/","title":"Iptables"},{"content":"现状 某些网站打开，因为当前网络等其他原因，无法正常访问页面，只能显示网站的基本文字，而没有图片，样式等\n产生原因 当前网站的样式地址、静态文件地址，无法访问，或者不安全被浏览器拦截\n解决办法 打开无法正常访问的网站 F12，打开审查，切换到 Network tab页，刷新页面，会发现很多地址都是显示红色 选择任意一个红色的无法访问的地址，双击打开，会发现浏览器出现隐私错误提示 高级，仍然访问，(或者直接在当前页面上键盘输入 thisisunsafe) 当前页面会刷新重新访问，并正常访问 这时，继续切换到 该网站 的标签页，刷新，会发现当前页面可以正常访问了 猜测 猜测该类网站无法访问，是因为Chrome不信任这些静态资源地址自签名ssl证书，为了安全起见，直接禁止访问了\n","date":"2022-10-23T15:14:25+08:00","permalink":"https://codeSu97.github.io/p/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E7%BC%BA%E5%B0%91%E6%A0%B7%E5%BC%8F/","title":"访问网站缺少样式"},{"content":" “Yeah It\u0026rsquo;s on. ”\n","date":"2022-10-12T19:31:57+08:00","image":"https://codeSu97.github.io/p/hello-world/hello-world_hu_aa0de37877cc16eb.png","permalink":"https://codeSu97.github.io/p/hello-world/","title":"Hello World"}]