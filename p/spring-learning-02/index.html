<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='什么是 Spring IoC? Spring IoC（Inversion of Control，控制反转）是 Spring 框架的核心机制，其核心思想是将对象的创建、依赖管理和生命周期交给容器统一控制，而非由开发者手动通过 new 创建对象。\n通过 IoC，代码的耦合度降低，程序的灵活性和可维护性显著提高。\n例如，如果一个用户服务需要数据库连接，容器会确保数据库连接被正确注入，而无需手动创建。\n负责管理对象的生命周期和依赖关系。 它通过依赖注入（Dependency Injection, DI）来实例化、配置和组装被称为“bean”的对象。 配置元数据可以是 XML、Java 注解或 Java 代码，增强了系统的模块化和灵活性. 依赖查找 价值 灵活应对运行时需求：有些依赖需要根据实时条件获取，比如按不同场景或配置，动态选择不同实现，这时直接注入一个固定 bean 可能不够灵活，需要主动查找。 工具或框架类的特殊需求：一些工具类或公共组件并不便于被注入到特定对象中，反而使用依赖查找更符合设计。比如在某些自定义 Starter 或底层框架中，可能会在初始化流程中需要访问容器本身。 在特定场景临时获取 bean：有时你需要延迟获取某些依赖，或想在调用时才加载/初始化（如懒加载），这时依赖查找也比提前注入更合适。 实现 通过\u00a0BeanFactory\u00a0基础接口 1 2 3 4 5 6 7 8 9 10 11 // 1. 创建容器 BeanFactory factory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); // 2. 查找 Bean（按名称） UserService userService = (UserService) factory.getBean("userService"); // 3. 按类型查找（Spring 5+） UserService userService = factory.getBean(UserService.class); // 4. 按注解查找 UserService userService = factory.getBeansWithAnnotation(UserService.class); 特点：\n'><title>Spring学习笔记02 - Spring IoC</title>
<link rel=canonical href=https://codeSu97.github.io/p/spring-learning-02/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Spring学习笔记02 - Spring IoC"><meta property='og:description' content='什么是 Spring IoC? Spring IoC（Inversion of Control，控制反转）是 Spring 框架的核心机制，其核心思想是将对象的创建、依赖管理和生命周期交给容器统一控制，而非由开发者手动通过 new 创建对象。\n通过 IoC，代码的耦合度降低，程序的灵活性和可维护性显著提高。\n例如，如果一个用户服务需要数据库连接，容器会确保数据库连接被正确注入，而无需手动创建。\n负责管理对象的生命周期和依赖关系。 它通过依赖注入（Dependency Injection, DI）来实例化、配置和组装被称为“bean”的对象。 配置元数据可以是 XML、Java 注解或 Java 代码，增强了系统的模块化和灵活性. 依赖查找 价值 灵活应对运行时需求：有些依赖需要根据实时条件获取，比如按不同场景或配置，动态选择不同实现，这时直接注入一个固定 bean 可能不够灵活，需要主动查找。 工具或框架类的特殊需求：一些工具类或公共组件并不便于被注入到特定对象中，反而使用依赖查找更符合设计。比如在某些自定义 Starter 或底层框架中，可能会在初始化流程中需要访问容器本身。 在特定场景临时获取 bean：有时你需要延迟获取某些依赖，或想在调用时才加载/初始化（如懒加载），这时依赖查找也比提前注入更合适。 实现 通过\u00a0BeanFactory\u00a0基础接口 1 2 3 4 5 6 7 8 9 10 11 // 1. 创建容器 BeanFactory factory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); // 2. 查找 Bean（按名称） UserService userService = (UserService) factory.getBean("userService"); // 3. 按类型查找（Spring 5+） UserService userService = factory.getBean(UserService.class); // 4. 按注解查找 UserService userService = factory.getBeansWithAnnotation(UserService.class); 特点：\n'><meta property='og:url' content='https://codeSu97.github.io/p/spring-learning-02/'><meta property='og:site_name' content='XiaoYp - Blog'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Spring'><meta property='article:tag' content='Java'><meta property='article:tag' content='Spring IoC'><meta property='article:published_time' content='2024-03-17T14:44:31+08:00'><meta property='article:modified_time' content='2024-03-17T14:44:31+08:00'><meta name=twitter:title content="Spring学习笔记02 - Spring IoC"><meta name=twitter:description content='什么是 Spring IoC? Spring IoC（Inversion of Control，控制反转）是 Spring 框架的核心机制，其核心思想是将对象的创建、依赖管理和生命周期交给容器统一控制，而非由开发者手动通过 new 创建对象。\n通过 IoC，代码的耦合度降低，程序的灵活性和可维护性显著提高。\n例如，如果一个用户服务需要数据库连接，容器会确保数据库连接被正确注入，而无需手动创建。\n负责管理对象的生命周期和依赖关系。 它通过依赖注入（Dependency Injection, DI）来实例化、配置和组装被称为“bean”的对象。 配置元数据可以是 XML、Java 注解或 Java 代码，增强了系统的模块化和灵活性. 依赖查找 价值 灵活应对运行时需求：有些依赖需要根据实时条件获取，比如按不同场景或配置，动态选择不同实现，这时直接注入一个固定 bean 可能不够灵活，需要主动查找。 工具或框架类的特殊需求：一些工具类或公共组件并不便于被注入到特定对象中，反而使用依赖查找更符合设计。比如在某些自定义 Starter 或底层框架中，可能会在初始化流程中需要访问容器本身。 在特定场景临时获取 bean：有时你需要延迟获取某些依赖，或想在调用时才加载/初始化（如懒加载），这时依赖查找也比提前注入更合适。 实现 通过\u00a0BeanFactory\u00a0基础接口 1 2 3 4 5 6 7 8 9 10 11 // 1. 创建容器 BeanFactory factory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); // 2. 查找 Bean（按名称） UserService userService = (UserService) factory.getBean("userService"); // 3. 按类型查找（Spring 5+） UserService userService = factory.getBean(UserService.class); // 4. 按注解查找 UserService userService = factory.getBeansWithAnnotation(UserService.class); 特点：\n'><link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/37898221?v=4"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky compact"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src="https://avatars.githubusercontent.com/u/37898221?v=4" width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🇨🇳</span></figure><div class=site-meta><h1 class=site-name><a href=/>XiaoYp - Blog</a></h1><h2 class=site-description>想都是问题，做才是答案</h2></div></header><ol class=menu-social><li><a href=https://github.com/XiaoYp97 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>首页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#什么是-spring-ioc>什么是 Spring IoC?</a></li><li><a href=#依赖查找>依赖查找</a><ol><li><a href=#价值>价值</a></li><li><a href=#实现>实现</a><ol><li><a href=#通过beanfactory基础接口>通过 <code>BeanFactory</code> 基础接口</a></li><li><a href=#通过-applicationcontext-接口>通过 <code>ApplicationContext</code> 接口</a></li><li><a href=#通过-objectprovider延迟可选依赖查找>通过 <code>ObjectProvider</code>（延迟/可选依赖查找）</a></li><li><a href=#通过-autowired--applicationcontextaware>通过 <code>@Autowired</code> + <code>ApplicationContextAware</code></a></li><li><a href=#通过注解扫描基于-componentscan>通过注解扫描（基于 <code>@ComponentScan</code>）</a></li><li><a href=#通过-jndi-查找传统方式>通过 JNDI 查找（传统方式）</a></li><li><a href=#通过静态方法web-环境专用>通过静态方法（Web 环境专用）</a></li><li><a href=#对比>对比</a></li></ol></li></ol></li><li><a href=#依赖注入>依赖注入</a></li><li><a href=#依赖来源>依赖来源</a></li><li><a href=#元信息>元信息</a><ol><li><a href=#配置元信息>配置元信息</a></li></ol></li><li><a href=#autowired-和-resource-的区别>@Autowired 和 @Resource 的区别</a><ol><li><a href=#注入机制>注入机制</a></li><li><a href=#是否必需>是否必需</a></li><li><a href=#标准与框架>标准与框架</a></li><li><a href=#使用场景>使用场景</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/spring/>Spring</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/spring-learning-02/>Spring学习笔记02 - Spring IoC</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-03-17</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 4 分钟</time></div></footer></div></header><section class=article-content><h2 id=什么是-spring-ioc>什么是 Spring IoC?</h2><p>Spring IoC（Inversion of Control，控制反转）是 Spring 框架的核心机制，其核心思想是将对象的创建、依赖管理和生命周期交给容器统一控制，而非由开发者手动通过 new 创建对象。</p><p>通过 IoC，代码的耦合度降低，程序的灵活性和可维护性显著提高。</p><p><em>例如，如果一个用户服务需要数据库连接，容器会确保数据库连接被正确注入，而无需手动创建。</em></p><ul><li>负责管理对象的生命周期和依赖关系。</li><li>它通过依赖注入（Dependency Injection, DI）来实例化、配置和组装被称为“bean”的对象。</li><li>配置元数据可以是 XML、Java 注解或 Java 代码，增强了系统的模块化和灵活性.</li></ul><h2 id=依赖查找>依赖查找</h2><h3 id=价值>价值</h3><ul><li>灵活应对运行时需求：有些依赖需要根据实时条件获取，比如按不同场景或配置，动态选择不同实现，这时直接注入一个固定 bean 可能不够灵活，需要主动查找。</li><li>工具或框架类的特殊需求：一些工具类或公共组件并不便于被注入到特定对象中，反而使用依赖查找更符合设计。比如在某些自定义 Starter 或底层框架中，可能会在初始化流程中需要访问容器本身。</li><li>在特定场景临时获取 bean：有时你需要延迟获取某些依赖，或想在调用时才加载/初始化（如懒加载），这时依赖查找也比提前注入更合适。</li></ul><h3 id=实现>实现</h3><h4 id=通过beanfactory基础接口>通过 <code>BeanFactory</code> 基础接口</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 1. 创建容器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>BeanFactory</span><span class=w> </span><span class=n>factory</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>XmlBeanFactory</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ClassPathResource</span><span class=p>(</span><span class=s>&#34;applicationContext.xml&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 2. 查找 Bean（按名称）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>UserService</span><span class=p>)</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=s>&#34;userService&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 3. 按类型查找（Spring 5+）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=n>UserService</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 4. 按注解查找</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>getBeansWithAnnotation</span><span class=p>(</span><span class=n>UserService</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>特点</strong>：</p><ul><li>最原始的 IoC 容器接口</li><li>需要手动处理类型转换</li><li>适用于简单场景（现代项目更常用 <code>ApplicationContext</code>）</li></ul><h4 id=通过-applicationcontext-接口>通过 <code>ApplicationContext</code> 接口</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 1. 初始化容器（XML 配置）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ApplicationContext</span><span class=w> </span><span class=n>context</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ClassPathXmlApplicationContext</span><span class=p>(</span><span class=s>&#34;applicationContext.xml&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 2. 按名称查找</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>UserService</span><span class=p>)</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=s>&#34;userService&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 3. 按类型查找（推荐）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=n>UserService</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 4. 按名称+类型查找（无需强制转换）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=s>&#34;userService&#34;</span><span class=p>,</span><span class=w> </span><span class=n>UserService</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>特点</strong>：</p><ul><li>企业级容器接口，支持事件、国际化等扩展功能</li><li>推荐使用 <code>getBean(Class&lt;T>)</code> 避免类型转换错误</li></ul><h4 id=通过-objectprovider延迟可选依赖查找>通过 <code>ObjectProvider</code>（延迟/可选依赖查找）</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 注入 ObjectProvider（Spring 4.3+）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>ObjectProvider</span><span class=o>&lt;</span><span class=n>UserService</span><span class=o>&gt;</span><span class=w> </span><span class=n>userServiceProvider</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 延迟获取 Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userServiceProvider</span><span class=p>.</span><span class=na>getIfAvailable</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 处理多个候选 Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userServiceProvider</span><span class=p>.</span><span class=na>getIfUnique</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 显式指定条件（如通过 @Qualifier 的变体）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userServiceProvider</span><span class=p>.</span><span class=na>getObject</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>特点</strong>：</p><ul><li>支持延迟加载和可选依赖</li><li>解决 <code>NoUniqueBeanDefinitionException</code> 问题</li><li>结合 <code>@Lazy</code> 注解可实现懒加载</li></ul><h4 id=通过-autowired--applicationcontextaware>通过 <code>@Autowired</code> + <code>ApplicationContextAware</code></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyBean</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ApplicationContextAware</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>ApplicationContext</span><span class=w> </span><span class=n>context</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setApplicationContext</span><span class=p>(</span><span class=n>ApplicationContext</span><span class=w> </span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>context</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>doSomething</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=n>UserService</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>特点</strong>：</p><ul><li>将容器上下文注入到 Bean 中</li><li>适用于需要动态查找的场景</li></ul><h4 id=通过注解扫描基于-componentscan>通过注解扫描（基于 <code>@ComponentScan</code>）</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@ComponentScan</span><span class=p>(</span><span class=s>&#34;com.example&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AppConfig</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 初始化容器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ApplicationContext</span><span class=w> </span><span class=n>context</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AnnotationConfigApplicationContext</span><span class=p>(</span><span class=n>AppConfig</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 查找带有 @Component 的 Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserRepository</span><span class=w> </span><span class=n>repo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=n>UserRepository</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>特点</strong>：</p><ul><li>结合组件扫描自动注册 Bean</li><li>隐式依赖查找的基础</li></ul><h4 id=通过-jndi-查找传统方式>通过 JNDI 查找（传统方式）</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 在 Spring XML 配置中声明 JNDI 资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>jee</span><span class=p>:</span><span class=n>jndi</span><span class=o>-</span><span class=n>lookup</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=s>&#34;dataSource&#34;</span><span class=w> </span><span class=n>jndi</span><span class=o>-</span><span class=n>name</span><span class=o>=</span><span class=s>&#34;java:comp/env/jdbc/mydb&#34;</span><span class=o>/&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 通过容器查找</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>DataSource</span><span class=w> </span><span class=n>dataSource</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>DataSource</span><span class=p>)</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=s>&#34;dataSource&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>特点</strong>：</p><ul><li>适用于 Java EE 环境整合</li><li>现代项目更多使用 <code>@Bean</code> 配置数据源</li></ul><h4 id=通过静态方法web-环境专用>通过静态方法（Web 环境专用）</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 获取 WebApplicationContext（如 Servlet 环境）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>WebApplicationContext</span><span class=w> </span><span class=n>context</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>WebApplicationContextUtils</span><span class=p>.</span><span class=na>getWebApplicationContext</span><span class=p>(</span><span class=n>servletContext</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 查找 Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=n>UserService</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=对比>对比</h4><div class=table-wrapper><table><thead><tr><th>方式</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>BeanFactory</code></td><td>简单容器操作</td><td>轻量级</td><td>功能有限</td></tr><tr><td><code>ApplicationContext</code></td><td>企业级应用（主流选择）</td><td>功能全面</td><td>稍重</td></tr><tr><td><code>ObjectProvider</code></td><td>处理延迟/可选依赖</td><td>解决多候选 Bean 问题</td><td>需要 Spring 4.3+</td></tr><tr><td><code>@Autowired</code> + 上下文</td><td>动态查找场景</td><td>灵活</td><td>侵入性强</td></tr><tr><td>注解扫描</td><td>自动装配的基础</td><td>简化配置</td><td>需配合组件扫描</td></tr></tbody></table></div><p><strong>推荐实践</strong>：</p><ul><li>优先使用依赖注入（被动获取）</li><li>仅在需要动态获取时使用依赖查找（如工厂模式、插件化架构）</li><li>现代项目首选 <code>ApplicationContext.getBean()</code> 或 <code>ObjectProvider</code></li></ul><h2 id=依赖注入>依赖注入</h2><p>依赖注入（Dependency Inject, DI）是 Spring 框架的核心功能，体现了控制反转（IoC）的设计原则。通过 DI，Spring IoC 容器负责创建和管理 bean 的依赖，并将这些依赖注入到目标 bean 中。注入方式包括：</p><ul><li><strong>构造函数注入</strong>：通过构造函数传递依赖。<ul><li>优点<ul><li>使用 final 关键字，不可变，对象创建后，依赖不可变</li><li>依赖关系明确，显著降低了组件之间的耦合性，使代码更易于测试和维护。</li><li>易于测试，可以直接传递模拟依赖</li><li>Spring 会在启动时确保所有依赖都已注入，避免运行时空指针异常</li></ul></li><li>缺点<ul><li>如果依赖多，构造函数可能过长</li><li>缺乏灵活性，创建后无法更改依赖</li></ul></li></ul></li><li><strong>setter 注入</strong>：通过 setter 方法设置依赖。<ul><li>优点<ul><li>灵活，可在对象创建后设置或更改依赖</li><li>适合可选依赖，可能不总是需要的</li><li>易于扩展，如果后期需要添加新依赖，只需添加新的 setter 方法</li></ul></li><li>缺点<ul><li>对象可变，可能导致状态不一致</li><li>未设置依赖，导致空指针异常</li></ul></li></ul></li><li><strong>字段注入</strong>：通过注解（如 @Autowired）直接在字段上注入依赖，Spring 会使用反射机制在对象创建后自动设置字段的值。<ul><li>优点<ul><li>代码简洁，无需编写 setter 或构造函数</li><li>使用简单，易于实现</li><li>Spring 会在启动时确保依赖注入，减少手动配置</li></ul></li><li>缺点<ul><li>与 Spring 框架紧密耦合，增加依赖</li><li>依赖关系不显眼，测试可能更复杂</li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>MyDependency</span><span class=w> </span><span class=n>dependency</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// 构造函数注入</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>MyService</span><span class=p>(</span><span class=n>MyDependency</span><span class=w> </span><span class=n>dependency</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>dependency</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dependency</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>doSomething</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dependency</span><span class=p>.</span><span class=na>execute</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>MyDependency</span><span class=w> </span><span class=n>dependency</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// Setter 注入</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setDependency</span><span class=p>(</span><span class=n>MyDependency</span><span class=w> </span><span class=n>dependency</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>dependency</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dependency</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// 字段注入</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>MyDependency</span><span class=w> </span><span class=n>dependency</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=依赖来源>依赖来源</h2><p><strong>依赖对象的来源</strong>主要就是 Spring IoC 容器（<code>BeanFactory</code> 或 <code>ApplicationContext</code>）本身。容器根据 XML、注解、Java Config 等方式加载 bean 定义并实例化这些对象，管理它们的生命周期，然后通过依赖注入或依赖查找将它们提供给应用使用。</p><ul><li>自定义 Bean<ul><li>自己编写并交给 Spring 管理的类，比如带有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类，或者在 XML/JavaConfig 中显式声明的 Bean。</li></ul></li><li>容器内建的 Bean<ul><li>Spring 容器在启动或运行过程中，会自动创建并维护一些基础设施类或辅助功能类，供框架内部或用户使用</li><li>比如 <code>ApplicationContext</code> 自身、<code>Environment</code>、<code>ResourceLoader</code>、<code>ConversionService</code>、<code>MessageSource</code>、<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code> 以及各种内部用来处理注解、AOP、事务等功能的 Bean</li><li><code>Environment environment = applicationContext.getBean(Environment.class);</code></li></ul></li><li>容器内建的依赖，（依赖注入）<ul><li>指的是那些不一定以 Bean 形式出现，但由容器提供、可被注入或查找的依赖。例如：</li><li><code>BeanFactory</code> / <code>ApplicationContext</code>：在使用 <code>@Autowired</code> 时可以直接注入 <code>ApplicationContext</code>；</li><li>环境变量、配置属性：通过 <code>@Value("${property}")</code> 或 <code>Environment</code> 对象获取；</li><li>事件发布器（<code>ApplicationEventPublisher</code>）、任务调度器（<code>TaskScheduler</code>）等容器级别的基础依赖。</li><li>这些依赖在某些情况下也会以 Bean 的形式出现，但总体上它们属于 Spring 内部或与运行环境强相关的内容，是容器层面“提供”的依赖。</li></ul></li></ul><h2 id=元信息>元信息</h2><ul><li><strong>Bean 的标识</strong><ul><li>包括 Bean 名称（<code>id</code> 或 <code>name</code>）、Bean 所对应的类名、别名等。</li></ul></li><li><strong>Bean 的作用域（Scope）</strong><ul><li>常见的有 <code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code> 等。</li><li>用于决定容器如何缓存或创建 Bean 实例。</li></ul></li><li><strong>依赖注入信息</strong><ul><li>包括构造器参数、Setter 方法注入、字段注入等。</li><li>哪些依赖是必须的？哪些是可选的？</li></ul></li><li><strong>生命周期回调（Lifecycle callbacks）</strong>：<ul><li>初始化方法（<code>init-method</code> 或 <code>@PostConstruct</code>）、</li><li>销毁方法（<code>destroy-method</code> 或 <code>@PreDestroy</code>）等</li></ul></li><li><strong>条件或环境</strong>：<ul><li>比如 <code>@Conditional</code> 注解可以决定是否加载某个 Bean；</li><li>或者 <code>@Profile</code> 控制在特定环境（dev, test, prod）下是否启用某些 Bean。</li></ul></li><li><strong>其他配置</strong>：<ul><li>是否使用 AOP、事务等功能；</li><li>是否启用延迟加载（lazy-init）；</li><li>是否是自动装配（autowire），等等。</li></ul></li></ul><h3 id=配置元信息>配置元信息</h3><ul><li>Bean 定义配置<ul><li>基于 XML 文件</li><li>基于 Properties 文件</li><li>基于 Java 注解</li><li>基于 Java API</li></ul></li><li>IoC 容器配置<ul><li>基于 XML 文件</li><li>基于 Java 注解</li><li>基于 Java API</li></ul></li><li>外部化属性配置<ul><li>基于 Java 注解，@Value</li></ul></li></ul><h2 id=autowired-和-resource-的区别>@Autowired 和 @Resource 的区别</h2><h3 id=注入机制>注入机制</h3><ul><li><strong>@Autowired</strong> 是基于类型的注入。<ul><li>它会查找与字段或参数类型匹配的 bean。例如，如果一个字段是 MyDependency 类型，Spring 会注入所有实现 MyDependency 接口的 bean。</li></ul></li><li><strong>@Resource</strong> 是基于名称的注入。<ul><li>它会根据字段名称或显式指定的名称查找 bean。例如，如果字段名为 dependency，它会查找名为 &ldquo;dependency&rdquo; 的 bean。</li><li>@Resource 还可以用于注入资源（如 DataSource），而不仅仅是 bean，这在某些复杂场景下可能更灵活。</li></ul></li></ul><h3 id=是否必需>是否必需</h3><ul><li><strong>@Autowired</strong> 默认是必需的。如果找不到匹配的 bean，Spring 会抛出异常。但你可以通过 required = false使它可选。</li><li><strong>@Resource</strong> 默认是可选的。如果找不到匹配的 bean，字段会保持为 null，无需额外配置。</li></ul><h3 id=标准与框架>标准与框架</h3><ul><li><strong>@Autowired</strong> 是 Spring 框架专有的注解，适合深度集成 Spring 的项目。</li><li><strong>@Resource</strong> 是 Java 标准的一部分（JSR-250），在 Java EE 环境中也常用，适合希望减少框架依赖的项目。</li></ul><h3 id=使用场景>使用场景</h3><ul><li>如果你需要基于类型的注入，且依赖是必需的，推荐使用 @Autowired。例如：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>MyDependency</span><span class=w> </span><span class=n>dependency</span><span class=p>;</span><span class=w> </span><span class=c1>// 注入类型为 MyDependency 的 bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>如果你需要基于名称的注入，或依赖是可选的，推荐使用 @Resource。例如：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Resource</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;specificDependency&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>private</span><span class=w> </span><span class=n>MyDependency</span><span class=w> </span><span class=n>dependency</span><span class=p>;</span><span class=w> </span><span class=c1>// 注入名为 &#34;specificDependency&#34; 的 bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></section><footer class=article-footer><section class=article-tags><a href=/tags/spring/>Spring</a>
<a href=/tags/java/>Java</a>
<a href=/tags/spring-ioc/>Spring IoC</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/spring-learning-01/><div class=article-details><h2 class=article-title>Spring学习笔记01 - Spring Framework</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2022 -
2025 XiaoYp - Blog</section><section class=powerby>想都是问题，做才是答案！<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>