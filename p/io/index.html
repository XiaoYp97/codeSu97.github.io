<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="什么是IO IO，英文全称是Input/Output，即输入/输出。\n计算机角度的IO 我们常说的输入输出，比较直观的意思就是计算机的输入输出，计算机就是主体。\n冯.诺依曼结构，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。\n输入设备是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备； 输出设备是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。 鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，涉及计算机核心与其他设备间数据迁移的过程，就是IO。\n如磁盘IO，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是IO的本质。\n操作系统的IO 我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。\n操作系统负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过操作系统，才能做一些特殊操作，如磁盘文件读写、内存的读写等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。\n什么是用户空间？什么是内核空间?\n以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。\n我们应用程序是跑在用户空间的，它不存在实质的IO过程，真正的IO是在操作系统执行的。即应用程序的IO操作分为两种动作：IO调用和IO执行。IO调用是由进程（应用程序的运行态）发起，而IO执行是操作系统内核的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。\n操作系统的一次IO过程 应用程序发起的一次IO操作包含两个阶段：\nIO调用：应用程序进程向操作系统内核发起调用。 IO执行：操作系统内核完成IO操作。 操作系统内核完成IO操作还包括两个过程：\n准备数据：内核等待I/O设备准备好数据。 拷贝数据：将数据从内核缓冲区拷贝到用户进程缓冲区。 其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的IO过程包括以下几个步骤：\n应用程序进程向操作系统发起IO调用请求 操作系统准备数据，把IO外部设备的数据，加载到内核缓冲区 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区 IO模型 阻塞IO模型 (BIO, Blocking I/O) 假设应用程序的进程发起IO调用，但是如果内核的数据还没准备好的话，那应用程序进程就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为阻塞IO。\n阻塞IO比较经典的应用就是阻塞socket、Java BIO。 阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，浪费性能，可以使用非阻塞IO优化。 非阻塞IO模型 (NIO, Non-Blocking I/O) 如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下：\n非阻塞IO的流程如下：\n应用进程向操作系统内核，发起recvfrom读取数据。 操作系统内核数据没有准备好，立即返回EWOULDBLOCK错误码。 应用程序进程轮询调用，继续向操作系统内核发起recvfrom读取数据。 操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。 完成调用，返回成功提示。 非阻塞IO模型，简称NIO，Non-Blocking IO。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在性能问题，即频繁的轮询，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑IO复用模型，去解决这个问题。\n"><title>I/O</title>
<link rel=canonical href=https://codeSu97.github.io/p/io/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="I/O"><meta property='og:description' content="什么是IO IO，英文全称是Input/Output，即输入/输出。\n计算机角度的IO 我们常说的输入输出，比较直观的意思就是计算机的输入输出，计算机就是主体。\n冯.诺依曼结构，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。\n输入设备是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备； 输出设备是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。 鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，涉及计算机核心与其他设备间数据迁移的过程，就是IO。\n如磁盘IO，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是IO的本质。\n操作系统的IO 我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。\n操作系统负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过操作系统，才能做一些特殊操作，如磁盘文件读写、内存的读写等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。\n什么是用户空间？什么是内核空间?\n以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。\n我们应用程序是跑在用户空间的，它不存在实质的IO过程，真正的IO是在操作系统执行的。即应用程序的IO操作分为两种动作：IO调用和IO执行。IO调用是由进程（应用程序的运行态）发起，而IO执行是操作系统内核的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。\n操作系统的一次IO过程 应用程序发起的一次IO操作包含两个阶段：\nIO调用：应用程序进程向操作系统内核发起调用。 IO执行：操作系统内核完成IO操作。 操作系统内核完成IO操作还包括两个过程：\n准备数据：内核等待I/O设备准备好数据。 拷贝数据：将数据从内核缓冲区拷贝到用户进程缓冲区。 其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的IO过程包括以下几个步骤：\n应用程序进程向操作系统发起IO调用请求 操作系统准备数据，把IO外部设备的数据，加载到内核缓冲区 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区 IO模型 阻塞IO模型 (BIO, Blocking I/O) 假设应用程序的进程发起IO调用，但是如果内核的数据还没准备好的话，那应用程序进程就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为阻塞IO。\n阻塞IO比较经典的应用就是阻塞socket、Java BIO。 阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，浪费性能，可以使用非阻塞IO优化。 非阻塞IO模型 (NIO, Non-Blocking I/O) 如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下：\n非阻塞IO的流程如下：\n应用进程向操作系统内核，发起recvfrom读取数据。 操作系统内核数据没有准备好，立即返回EWOULDBLOCK错误码。 应用程序进程轮询调用，继续向操作系统内核发起recvfrom读取数据。 操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。 完成调用，返回成功提示。 非阻塞IO模型，简称NIO，Non-Blocking IO。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在性能问题，即频繁的轮询，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑IO复用模型，去解决这个问题。\n"><meta property='og:url' content='https://codeSu97.github.io/p/io/'><meta property='og:site_name' content='XiaoYp - Blog'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='IO'><meta property='article:published_time' content='2024-05-31T11:20:31+08:00'><meta property='article:modified_time' content='2024-05-31T11:20:31+08:00'><meta name=twitter:title content="I/O"><meta name=twitter:description content="什么是IO IO，英文全称是Input/Output，即输入/输出。\n计算机角度的IO 我们常说的输入输出，比较直观的意思就是计算机的输入输出，计算机就是主体。\n冯.诺依曼结构，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。\n输入设备是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备； 输出设备是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。 鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，涉及计算机核心与其他设备间数据迁移的过程，就是IO。\n如磁盘IO，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是IO的本质。\n操作系统的IO 我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。\n操作系统负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过操作系统，才能做一些特殊操作，如磁盘文件读写、内存的读写等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。\n什么是用户空间？什么是内核空间?\n以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。\n我们应用程序是跑在用户空间的，它不存在实质的IO过程，真正的IO是在操作系统执行的。即应用程序的IO操作分为两种动作：IO调用和IO执行。IO调用是由进程（应用程序的运行态）发起，而IO执行是操作系统内核的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。\n操作系统的一次IO过程 应用程序发起的一次IO操作包含两个阶段：\nIO调用：应用程序进程向操作系统内核发起调用。 IO执行：操作系统内核完成IO操作。 操作系统内核完成IO操作还包括两个过程：\n准备数据：内核等待I/O设备准备好数据。 拷贝数据：将数据从内核缓冲区拷贝到用户进程缓冲区。 其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的IO过程包括以下几个步骤：\n应用程序进程向操作系统发起IO调用请求 操作系统准备数据，把IO外部设备的数据，加载到内核缓冲区 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区 IO模型 阻塞IO模型 (BIO, Blocking I/O) 假设应用程序的进程发起IO调用，但是如果内核的数据还没准备好的话，那应用程序进程就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为阻塞IO。\n阻塞IO比较经典的应用就是阻塞socket、Java BIO。 阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，浪费性能，可以使用非阻塞IO优化。 非阻塞IO模型 (NIO, Non-Blocking I/O) 如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下：\n非阻塞IO的流程如下：\n应用进程向操作系统内核，发起recvfrom读取数据。 操作系统内核数据没有准备好，立即返回EWOULDBLOCK错误码。 应用程序进程轮询调用，继续向操作系统内核发起recvfrom读取数据。 操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。 完成调用，返回成功提示。 非阻塞IO模型，简称NIO，Non-Blocking IO。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在性能问题，即频繁的轮询，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑IO复用模型，去解决这个问题。\n"><link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/37898221?v=4"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky compact"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src="https://avatars.githubusercontent.com/u/37898221?v=4" width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🇨🇳</span></figure><div class=site-meta><h1 class=site-name><a href=/>XiaoYp - Blog</a></h1><h2 class=site-description>想都是问题，做才是答案</h2></div></header><ol class=menu-social><li><a href=https://github.com/XiaoYp97 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>首页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#什么是io>什么是IO</a><ol><li><a href=#计算机角度的io>计算机角度的IO</a></li><li><a href=#操作系统的io>操作系统的IO</a></li></ol></li><li><a href=#操作系统的一次io过程>操作系统的一次IO过程</a></li><li><a href=#io模型>IO模型</a><ol><li><a href=#阻塞io模型-bio-blocking-io>阻塞IO模型 (BIO, Blocking I/O)</a></li><li><a href=#非阻塞io模型-nio-non-blocking-io>非阻塞IO模型 (NIO, Non-Blocking I/O)</a></li><li><a href=#多路复用io模型-mio-multiplexing-io>多路复用IO模型 (MIO, Multiplexing I/O)</a><ol><li><a href=#select>select</a></li><li><a href=#epoll>epoll</a></li><li><a href=#selectpollepoll的区别>select、poll、epoll的区别</a></li></ol></li><li><a href=#信号驱动io模型-sdio-signal-driven-io>信号驱动IO模型 (SDIO, Signal-driven I/O)</a></li><li><a href=#异步io模型-aio-asynchronous-io>异步IO模型 (AIO, Asynchronous I/O)</a></li></ol></li><li><a href=#阻塞非阻塞同步异步io划分>阻塞、非阻塞、同步、异步IO划分</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/io/>IO</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/io/>I/O</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-05-31</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 1 分钟</time></div></footer></div></header><section class=article-content><h2 id=什么是io>什么是IO</h2><p>IO，英文全称是<strong>Input/Output</strong>，<strong>即输入/输出</strong>。</p><h3 id=计算机角度的io>计算机角度的IO</h3><p>我们常说的输入输出，比较直观的意思就是<strong>计算机的输入输出</strong>，<strong>计算机就是主体</strong>。</p><p><strong>冯.诺依曼结构</strong>，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。</p><p><img src=/p/io/%E5%86%AF-%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.png width=1784 height=932 srcset="/p/io/%E5%86%AF-%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84_hu_604897a2b548d3fb.png 480w, /p/io/%E5%86%AF-%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84_hu_b2a2d5a893c71c27.png 1024w" loading=lazy alt=冯.诺依曼结构 class=gallery-image data-flex-grow=191 data-flex-basis=459px></p><ul><li>输入设备是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备；</li><li>输出设备是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。</li></ul><p>鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，<strong>涉及计算机核心与其他设备间数据迁移的过程，就是IO</strong>。</p><p>如磁盘IO，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是IO的本质。</p><h3 id=操作系统的io>操作系统的IO</h3><p>我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。</p><p><strong>操作系统</strong>负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过<strong>操作系统</strong>，才能做一些特殊操作，如<strong>磁盘文件读写、内存的读写</strong>等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。</p><blockquote><p><strong>什么是用户空间？什么是内核空间?</strong></p><p>以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。</p></blockquote><p>我们应用程序是跑在用户空间的，它不存在实质的IO过程，真正的IO是在<strong>操作系统</strong>执行的。即应用程序的IO操作分为两种动作：<strong>IO调用和IO执行</strong>。IO调用是由进程（应用程序的运行态）发起，而IO执行是<strong>操作系统内核</strong>的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。</p><h2 id=操作系统的一次io过程>操作系统的一次IO过程</h2><p>应用程序发起的一次IO操作包含两个阶段：</p><ul><li>IO调用：应用程序进程向操作系统<strong>内核</strong>发起调用。</li><li>IO执行：操作系统内核完成IO操作。</li></ul><p>操作系统内核完成IO操作还包括两个过程：</p><ul><li>准备数据：内核等待I/O设备准备好数据。</li><li>拷贝数据：将数据从内核缓冲区拷贝到用户进程缓冲区。</li></ul><p><img src=/p/io/IO%E8%BF%87%E7%A8%8B.png width=2160 height=1106 srcset="/p/io/IO%E8%BF%87%E7%A8%8B_hu_8deae71b6d751300.png 480w, /p/io/IO%E8%BF%87%E7%A8%8B_hu_5e8163623202590d.png 1024w" loading=lazy alt=IO过程 class=gallery-image data-flex-grow=195 data-flex-basis=468px></p><p>其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的<strong>IO过程</strong>包括以下几个步骤：</p><ul><li>应用程序进程向操作系统发起<strong>IO调用请求</strong></li><li>操作系统<strong>准备数据</strong>，把IO外部设备的数据，加载到<strong>内核缓冲区</strong></li><li>操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区</li></ul><h2 id=io模型>IO模型</h2><h3 id=阻塞io模型-bio-blocking-io>阻塞IO模型 (BIO, Blocking I/O)</h3><p>假设应用程序的进程发起<strong>IO调用</strong>，但是如果<strong>内核的数据还没准备好</strong>的话，那应用程序进程就一直在<strong>阻塞等待</strong>，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为<strong>阻塞IO</strong>。</p><p><img src=/p/io/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png width=2160 height=1130 srcset="/p/io/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B_hu_96fa08004de89fd9.png 480w, /p/io/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B_hu_e19611a2a189f803.png 1024w" loading=lazy alt=阻塞IO模型 class=gallery-image data-flex-grow=191 data-flex-basis=458px></p><ul><li>阻塞IO比较经典的应用就是<strong>阻塞socket、Java BIO</strong>。</li><li>阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，<strong>浪费性能</strong>，可以使用<strong>非阻塞IO</strong>优化。</li></ul><h3 id=非阻塞io模型-nio-non-blocking-io>非阻塞IO模型 (NIO, Non-Blocking I/O)</h3><p>如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，而是通过轮询的方式再来请求。这就是非阻塞IO，流程图如下：</p><p><img src=/p/io/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png width=2160 height=1528 srcset="/p/io/%E9%9D%9E%E9%98%BB%E5%A1%9EIO_hu_4c28639776292d8e.png 480w, /p/io/%E9%9D%9E%E9%98%BB%E5%A1%9EIO_hu_53fadcaaef01d490.png 1024w" loading=lazy alt=非阻塞IO class=gallery-image data-flex-grow=141 data-flex-basis=339px></p><p>非阻塞IO的流程如下：</p><ul><li>应用进程向操作系统内核，发起<code>recvfrom</code>读取数据。</li><li>操作系统内核数据没有准备好，立即返回<code>EWOULDBLOCK</code>错误码。</li><li>应用程序进程轮询调用，继续向操作系统内核发起<code>recvfrom</code>读取数据。</li><li>操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。</li><li>完成调用，返回成功提示。</li></ul><p>非阻塞IO模型，简称<strong>NIO</strong>，<code>Non-Blocking IO</code>。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在<strong>性能问题</strong>，即<strong>频繁的轮询</strong>，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑<strong>IO复用模型</strong>，去解决这个问题。</p><h3 id=多路复用io模型-mio-multiplexing-io>多路复用IO模型 (MIO, Multiplexing I/O)</h3><p>既然<strong>NIO</strong>无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用，那不就好了嘛？</p><p>在这之前，我们先来复习下，什么是<a class=link href=1.%e5%ad%a6%e4%b9%a0/Linux/%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6.md><strong>文件描述符fd</strong>(File Descriptor)</a>,它是计算机科学中的一个术语，形式上是一个非负整数。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><p>IO复用模型核心思路：系统给我们提供<strong>一类函数</strong>（如我们耳濡目染的<strong>select、poll、epoll</strong>函数），它们可以同时监控多个<code>fd</code>的操作，任何一个返回内核数据就绪，应用进程再发起<code>recvfrom</code>系统调用。</p><h4 id=select>select</h4><p>应用进程通过调用<strong>select</strong>函数，可以同时监控多个<code>fd</code>，在<code>select</code>函数监控的<code>fd</code>中，只要有任何一个数据状态准备就绪了，<code>select</code>函数就会返回可读状态，这时应用进程再发起<code>recvfrom</code>请求去读取数据。</p><p><img src=/p/io/select.png width=2160 height=1320 srcset="/p/io/select_hu_7d14980e6febe213.png 480w, /p/io/select_hu_bd2e0c412fc285a6.png 1024w" loading=lazy alt=select class=gallery-image data-flex-grow=163 data-flex-basis=392px></p><p>非阻塞IO模型（NIO）中，需要<code>N</code>（N>=1）次轮询系统调用，然而借助<code>select</code>的IO多路复用模型，只需要发起一次询问就够了,大大优化了性能。</p><p>但是呢，<code>select</code>有几个缺点：</p><ul><li>监听的IO最大连接数有限，在Linux系统上一般为1024。</li><li>select函数返回后，是通过<strong>遍历</strong><code>fdset</code>，找到就绪的描述符<code>fd</code>。（仅知道有I/O事件发生，却不知是哪几个流，所以<strong>遍历所有流</strong>）</li></ul><p>因为<strong>存在连接数限制</strong>，所以后来又提出了<strong>poll</strong>。与select相比，<strong>poll</strong>解决了<strong>连接数限制问题</strong>。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的<code>socket</code>。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，<strong>效率也会线性下降</strong>。</p><p>因此经典的多路复用模型<code>epoll</code>诞生。</p><h4 id=epoll>epoll</h4><p>为了解决<code>select/poll</code>存在的问题，多路复用模型<code>epoll</code>诞生，它采用事件驱动来实现，流程图如下：</p><p><img src=/p/io/epoll.png width=2160 height=1312 srcset="/p/io/epoll_hu_26385753c109246.png 480w, /p/io/epoll_hu_3fd15b2fd037a372.png 1024w" loading=lazy alt=epoll class=gallery-image data-flex-grow=164 data-flex-basis=395px></p><p><strong>epoll</strong>先通过<code>epoll_ctl()</code>来注册一个<code>fd</code>（文件描述符），一旦基于某个<code>fd</code>就绪时，内核会采用回调机制，迅速激活这个<code>fd</code>，当进程调用<code>epoll_wait()</code>时便得到通知。这里去掉了<strong>遍历文件描述符</strong>的坑爹操作，而是采用<strong>监听事件回调</strong>的机制。这就是epoll的亮点。</p><h4 id=selectpollepoll的区别>select、poll、epoll的区别</h4><div class=table-wrapper><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>底层数据结构</td><td>数组</td><td>链表</td><td>红黑树和双链表</td></tr><tr><td>获取就绪的fd</td><td>遍历</td><td>遍历</td><td>事件回调</td></tr><tr><td>事件复杂度</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>最大连接数</td><td>1024</td><td>无限制</td><td>无限制</td></tr><tr><td>fd数据拷贝</td><td>每次调用select，需要将fd数据从用户空间拷贝到内核空间</td><td>每次调用poll，需要将fd数据从用户空间拷贝到内核空间</td><td>使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间</td></tr></tbody></table></div><p><strong>epoll</strong>明显优化了IO的执行效率，但在进程调用<code>epoll_wait()</code>时，仍然可能被阻塞。</p><h3 id=信号驱动io模型-sdio-signal-driven-io>信号驱动IO模型 (SDIO, Signal-driven I/O)</h3><p>信号驱动IO不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（调用<code>sigaction</code>的时候建立一个<code>SIGIO</code>的信号），然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过<code>SIGIO</code>信号通知应用进程，数据准备好后的可读状态。应用用户进程收到信号之后，立即调用<code>recvfrom</code>，去读取数据。</p><p><img src=/p/io/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.png width=2160 height=1324 srcset="/p/io/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B_hu_a20f69c0ec854949.png 480w, /p/io/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B_hu_fb0f40ed63b73bfa.png 1024w" loading=lazy alt=信号驱动IO模型 class=gallery-image data-flex-grow=163 data-flex-basis=391px></p><p>信号驱动IO模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，<strong>发现数据复制到应用缓冲的时候</strong>，应用进程还是阻塞的。回过头来看下，不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。</p><h3 id=异步io模型-aio-asynchronous-io>异步IO模型 (AIO, Asynchronous I/O)</h3><p>前面讲的<code>BIO，NIO和SDIO</code>，在数据从内核复制到应用缓冲的时候，都是<strong>阻塞</strong>的，因此都不算是真正的异步。<code>AIO</code>实现了IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是<strong>立即返回的不是处理结果，而是表示提交成功类似的意思</strong>。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程IO操作执行完毕。</p><p><img src=/p/io/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png width=2160 height=1352 srcset="/p/io/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B_hu_7c09de5e6fbebc58.png 480w, /p/io/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B_hu_bb84c71d731079d4.png 1024w" loading=lazy alt=异步IO模型 class=gallery-image data-flex-grow=159 data-flex-basis=383px></p><p>异步IO的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。日常开发中，有类似思想的业务场景：</p><blockquote><p>比如发起一笔批量转账，但是批量转账处理比较耗时，这时候后端可以先告知前端转账提交成功，等到结果处理完，再通知前端结果即可。</p></blockquote><h2 id=阻塞非阻塞同步异步io划分>阻塞、非阻塞、同步、异步IO划分</h2><p><img src=/p/io/IO%E5%88%92%E5%88%86.png width=1620 height=806 srcset="/p/io/IO%E5%88%92%E5%88%86_hu_d2f7e3bd2fc99e22.png 480w, /p/io/IO%E5%88%92%E5%88%86_hu_fb7719876e9e7aa6.png 1024w" loading=lazy alt=IO划分 class=gallery-image data-flex-grow=200 data-flex-basis=482px></p><div class=table-wrapper><table><thead><tr><th>IO模型</th><th></th></tr></thead><tbody><tr><td>BIO</td><td>同步阻塞</td></tr><tr><td>NIO</td><td>同步非阻塞</td></tr><tr><td>MIO</td><td>同步阻塞</td></tr><tr><td>SDIO</td><td>同步非阻塞</td></tr><tr><td>AIO</td><td>异步非阻塞</td></tr></tbody></table></div></section><footer class=article-footer><section class=article-tags><a href=/tags/io/>IO</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><footer class=site-footer><section class=copyright>&copy;
2022 -
2025 XiaoYp - Blog</section><section class=powerby>想都是问题，做才是答案！<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>